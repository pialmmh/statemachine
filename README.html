<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TelcoBright State Machine Library - Technical Documentation</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f9fa;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            color: #34495e;
            margin-top: 30px;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 5px;
        }
        h3 {
            color: #7f8c8d;
            margin-top: 25px;
        }
        .toc {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 5px;
            padding: 20px;
            margin: 20px 0;
        }
        .toc h2 {
            margin-top: 0;
            color: #495057;
            border: none;
        }
        .toc ul {
            list-style-type: none;
            padding-left: 0;
        }
        .toc li {
            margin: 8px 0;
            padding-left: 20px;
        }
        .toc a {
            color: #007bff;
            text-decoration: none;
        }
        .toc a:hover {
            text-decoration: underline;
        }
        pre {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }
        code {
            background: #e9ecef;
            padding: 2px 5px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
        pre code {
            background: none;
            padding: 0;
        }
        .highlight {
            background: #fff3cd;
            padding: 15px;
            border-left: 4px solid #ffc107;
            margin: 20px 0;
        }
        .section {
            margin-bottom: 40px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #dee2e6;
            padding: 12px;
            text-align: left;
        }
        th {
            background: #f8f9fa;
            font-weight: 600;
        }
        .badge {
            display: inline-block;
            padding: 3px 8px;
            font-size: 12px;
            font-weight: 600;
            border-radius: 3px;
            margin: 0 5px;
        }
        .badge-primary { background: #007bff; color: white; }
        .badge-success { background: #28a745; color: white; }
        .badge-warning { background: #ffc107; color: #212529; }
        .badge-danger { background: #dc3545; color: white; }
        .badge-info { background: #17a2b8; color: white; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸš€ TelcoBright State Machine Library</h1>
        
        <div class="highlight">
            <strong>Quick Start:</strong> Run <code>./monitor-start.sh</code> to start the monitoring system, then access <code>http://localhost:8091</code>
        </div>

        <div class="toc">
            <h2>ğŸ“‹ Table of Contents</h2>
            <ul>
                <li>ğŸ“– <a href="#overview">Project Overview</a></li>
                <li>ğŸ—ï¸ <a href="#architecture">Architecture Components</a></li>
                <li>ğŸš€ <a href="#quickstart">Quick Start Guide</a></li>
                <li>ğŸ“Š <a href="#monitoring">Monitoring System</a></li>
                <li>ğŸ”Œ <a href="#websocket">WebSocket Integration</a></li>
                <li>ğŸ’¾ <a href="#database">Database Persistence</a></li>
                <li>ğŸ“ <a href="#structure">File Structure</a></li>
                <li>ğŸ”§ <a href="#configuration">Configuration</a></li>
                <li>ğŸ“ <a href="#examples">Examples</a></li>
                <li>ğŸ¯ <a href="#patterns">Design Patterns</a></li>
            </ul>
        </div>

        <div class="section" id="overview">
            <h2>ğŸ“– Project Overview</h2>
            <p>A comprehensive state machine framework with real-time monitoring, database persistence, and WebSocket-based live viewing capabilities. The system provides both historical snapshot viewing and live state transition monitoring through a web interface.</p>
            
            <h3>Key Features</h3>
            <ul>
                <li><span class="badge badge-primary">Core</span> Generic state machine implementation with hierarchical states</li>
                <li><span class="badge badge-success">Registry</span> Centralized management of multiple state machines</li>
                <li><span class="badge badge-info">Monitoring</span> Real-time WebSocket monitoring and historical snapshots</li>
                <li><span class="badge badge-warning">Persistence</span> PostgreSQL database integration for state history</li>
                <li><span class="badge badge-danger">Web UI</span> Dual-mode interface (Snapshot/Live viewing)</li>
            </ul>
        </div>

        <div class="section" id="architecture">
            <h2>ğŸ—ï¸ Architecture Components</h2>
            
            <h3>1. Core State Machine Framework</h3>
            <pre><code>// Generic state machine with three type parameters
StateMachine&lt;S, E, C&gt;
  S - State enum type
  E - Event enum type  
  C - Context type (implements StateMachineContextEntity)

// Configuration builder
StateMachineConfig&lt;S, E, C&gt;
  - Define states and transitions
  - Add entry/exit actions
  - Configure guards
  - Support hierarchical states</code></pre>

            <h3>2. State Machine Registry</h3>
            <pre><code>StateMachineRegistry&lt;TPersistentContext, TVolatileContext&gt;
  - createMachine(id, config, persistentContext, volatileContext)
  - rehydrateMachine(id, config, persistentContext, volatileContext)
  - removeMachine(id)
  - sendEvent(id, event)
  - addListener(listener)</code></pre>

            <h3>3. Listener Interface</h3>
            <pre><code>StateMachineListener&lt;TPersistentContext, TVolatileContext&gt;
  - onRegistryCreate(machineId)
  - onRegistryRehydrate(machineId)
  - onRegistryRemove(machineId)
  - onStateMachineEvent(machineId, oldState, newState, context)</code></pre>
        </div>

        <div class="section" id="quickstart">
            <h2>ğŸš€ Quick Start Guide</h2>
            
            <h3>Starting the Monitoring System</h3>
            <pre><code># Start both WebSocket server and Web UI
./monitor-start.sh

# This starts:
# - WebSocket server on port 9999
# - SimpleMonitoringServer on port 8091
# Access at: http://localhost:8091</code></pre>

            <h3>Running Demo State Machines</h3>
            <pre><code># Interactive CLI Monitor
mvn exec:java -Dexec.mainClass="com.telcobright.statemachine.monitoring.cli.StateMachineCliMonitor"

# WebSocket-enabled Runner
mvn exec:java -Dexec.mainClass="com.telcobright.statemachine.websocket.StateMachineRunnerWithWebServer"

# Minimal Test Runner
mvn exec:java -Dexec.mainClass="com.telcobright.statemachine.demo.MinimalUpdateRunner"</code></pre>
        </div>

        <div class="section" id="monitoring">
            <h2>ğŸ“Š Monitoring System</h2>
            
            <h3>SimpleMonitoringServer (Port 8091)</h3>
            <p>The "perfect" monitoring server with dual-mode interface:</p>
            
            <table>
                <thead>
                    <tr>
                        <th>Mode</th>
                        <th>Features</th>
                        <th>Use Case</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Snapshot Mode</strong> <span class="badge badge-primary">Default</span></td>
                        <td>
                            â€¢ Historical transitions from PostgreSQL<br>
                            â€¢ Context diff viewing (before/after)<br>
                            â€¢ Registry status tracking<br>
                            â€¢ Triggering class information
                        </td>
                        <td>Analyzing past state transitions and debugging</td>
                    </tr>
                    <tr>
                        <td><strong>Live Mode</strong> <span class="badge badge-success">WebSocket</span></td>
                        <td>
                            â€¢ Real-time state updates<br>
                            â€¢ Event sending panel<br>
                            â€¢ Editable JSON payloads<br>
                            â€¢ Connection status indicator
                        </td>
                        <td>Testing and monitoring active state machines</td>
                    </tr>
                </tbody>
            </table>

            <h3>Web UI Features</h3>
            <ul>
                <li>Purple gradient theme with responsive layout</li>
                <li>Left panel: Recent runs (Snapshot) / Event sender (Live)</li>
                <li>Right panel: History viewer / Live state display</li>
                <li>Database status indicator (top-right, small font)</li>
                <li>Mode toggle buttons: ğŸ“¸ Snapshot Viewer / ğŸ”´ Live Viewer</li>
                <li>Toast notifications for connection events</li>
            </ul>
        </div>

        <div class="section" id="websocket">
            <h2>ğŸ”Œ WebSocket Integration</h2>
            
            <h3>WebSocket Server (Port 9999)</h3>
            <pre><code>// Server broadcasts state changes
{
  "type": "STATE_CHANGE",
  "machineId": "call-123",
  "oldState": "IDLE",
  "newState": "RINGING",
  "context": { /* full context */ },
  "timestamp": "2024-01-01T12:00:00"
}</code></pre>

            <h3>Client Commands</h3>
            <pre><code>// Send event with payload
ws.send(JSON.stringify({
  action: "INCOMING_CALL",
  payload: { callerNumber: "+1-555-9999" }
}));

// Request current state
ws.send(JSON.stringify({
  action: "GET_STATE"
}));</code></pre>

            <h3>Supported Events</h3>
            <ul>
                <li><code>INCOMING_CALL</code> - Initiate incoming call</li>
                <li><code>ANSWER</code> - Answer the call</li>
                <li><code>HANGUP</code> - End the call</li>
                <li><code>SESSION_PROGRESS</code> - Session progress update</li>
            </ul>
        </div>

        <div class="section" id="database">
            <h2>ğŸ’¾ Database Persistence</h2>
            
            <h3>PostgreSQL Configuration</h3>
            <pre><code>Database: statemachine_monitoring
User: statemachine
Password: monitoring123
URL: jdbc:postgresql://localhost:5432/statemachine_monitoring</code></pre>

            <h3>Database Schema</h3>
            <pre><code>CREATE TABLE state_machine_snapshots (
    id BIGSERIAL PRIMARY KEY,
    run_id VARCHAR(255),
    machine_id VARCHAR(255),
    machine_type VARCHAR(100),
    version BIGINT,
    timestamp TIMESTAMP,
    state_before VARCHAR(100),
    state_after VARCHAR(100),
    event_type VARCHAR(100),
    transition_duration BIGINT,
    registry_status VARCHAR(50),
    machine_online_status BOOLEAN,
    event_payload_json TEXT,      -- Base64 encoded JSON
    context_before_json TEXT,     -- Base64 encoded JSON
    context_after_json TEXT,      -- Base64 encoded JSON
    registry_status_before VARCHAR(50),
    registry_status_after VARCHAR(50),
    machine_hydrated_before BOOLEAN,
    machine_hydrated_after BOOLEAN,
    event_sent_through_registry BOOLEAN,
    triggering_class_name VARCHAR(255),
    triggering_class_full_path VARCHAR(500)
);</code></pre>
        </div>

        <div class="section" id="structure">
            <h2>ğŸ“ File Structure</h2>
            <pre><code>src/main/java/com/telcobright/statemachine/
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ StateMachine.java                    # Core state machine implementation
â”‚   â”œâ”€â”€ StateMachineConfig.java              # Configuration builder
â”‚   â””â”€â”€ StateMachineContextEntity.java       # Base context interface
â”œâ”€â”€ registry/
â”‚   â”œâ”€â”€ StateMachineRegistry.java            # Centralized registry
â”‚   â””â”€â”€ StateMachineListener.java            # Event listener interface
â”œâ”€â”€ monitoring/
â”‚   â”œâ”€â”€ web/
â”‚   â”‚   â”œâ”€â”€ SimpleMonitoringServer.java      # Main web UI (port 8091)
â”‚   â”‚   â””â”€â”€ EnhancedMonitoringServer.java    # Alternative UI
â”‚   â”œâ”€â”€ cli/
â”‚   â”‚   â””â”€â”€ StateMachineCliMonitor.java      # Interactive CLI monitor
â”‚   â””â”€â”€ service/
â”‚       â””â”€â”€ MonitoringService.java           # Database persistence
â”œâ”€â”€ websocket/
â”‚   â”œâ”€â”€ StateMachineRunnerWithWebServer.java # WebSocket server (port 9999)
â”‚   â””â”€â”€ WebSocketMonitor.java                # WebSocket client
â”œâ”€â”€ demo/
â”‚   â”œâ”€â”€ call/
â”‚   â”‚   â”œâ”€â”€ CallMachine.java                 # Call state machine
â”‚   â”‚   â”œâ”€â”€ CallEntity.java                  # Persistent context
â”‚   â”‚   â””â”€â”€ CallContext.java                 # Volatile context
â”‚   â””â”€â”€ MinimalUpdateRunner.java             # Test runner
â””â”€â”€ persistence/
    â””â”€â”€ StateMachineSnapshot.java            # Snapshot entity</code></pre>
        </div>

        <div class="section" id="configuration">
            <h2>ğŸ”§ Configuration</h2>
            
            <h3>Maven Dependencies</h3>
            <pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.postgresql&lt;/groupId&gt;
    &lt;artifactId&gt;postgresql&lt;/artifactId&gt;
    &lt;version&gt;42.6.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.java-websocket&lt;/groupId&gt;
    &lt;artifactId&gt;Java-WebSocket&lt;/artifactId&gt;
    &lt;version&gt;1.5.4&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;
    &lt;artifactId&gt;gson&lt;/artifactId&gt;
    &lt;version&gt;2.10.1&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
        </div>

        <div class="section" id="examples">
            <h2>ğŸ“ Examples</h2>
            
            <h3>Call State Machine</h3>
            <pre><code>// States
public enum CallState {
    IDLE, INCOMING, OUTGOING, RINGING,
    IN_CALL, ON_HOLD, COMPLETED, FAILED
}

// Events
public enum CallEvent {
    INCOMING_CALL, OUTGOING_CALL, ANSWER,
    HANGUP, HOLD, RESUME, TIMEOUT, ERROR
}

// Configuration
StateMachineConfig&lt;CallState, CallEvent, CallEntity&gt; config = 
    new StateMachineConfig.Builder&lt;&gt;()
        .state(CallState.IDLE)
            .on(CallEvent.INCOMING_CALL).transitionTo(CallState.INCOMING)
            .on(CallEvent.OUTGOING_CALL).transitionTo(CallState.OUTGOING)
        .state(CallState.INCOMING)
            .onEntry(ctx -> log("Incoming call from " + ctx.getCallerNumber()))
            .on(CallEvent.ANSWER).transitionTo(CallState.IN_CALL)
            .on(CallEvent.HANGUP).transitionTo(CallState.COMPLETED)
        .build();</code></pre>

            <h3>Creating and Using Registry</h3>
            <pre><code>// Create registry
StateMachineRegistry&lt;CallEntity, CallContext&gt; registry = new StateMachineRegistry&lt;&gt;();

// Add listener for monitoring
registry.addListener(new StateMachineListener&lt;&gt;() {
    @Override
    public void onStateMachineEvent(String machineId, String oldState, 
                                   String newState, CallEntity entity, 
                                   CallContext context) {
        System.out.println("State change: " + oldState + " â†’ " + newState);
    }
});

// Create machine
CallEntity entity = new CallEntity();
CallContext context = new CallContext();
registry.createMachine("call-123", config, entity, context);

// Send event
registry.sendEvent("call-123", CallEvent.INCOMING_CALL);</code></pre>
        </div>

        <div class="section" id="patterns">
            <h2>ğŸ¯ Design Patterns</h2>
            
            <table>
                <thead>
                    <tr>
                        <th>Pattern</th>
                        <th>Usage</th>
                        <th>Benefits</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Registry Pattern</strong></td>
                        <td>Centralized state machine management</td>
                        <td>Single point of control, easy monitoring</td>
                    </tr>
                    <tr>
                        <td><strong>Observer Pattern</strong></td>
                        <td>State change notifications</td>
                        <td>Decoupled monitoring and logging</td>
                    </tr>
                    <tr>
                        <td><strong>Builder Pattern</strong></td>
                        <td>State machine configuration</td>
                        <td>Fluent API, type-safe configuration</td>
                    </tr>
                    <tr>
                        <td><strong>Repository Pattern</strong></td>
                        <td>Database persistence layer</td>
                        <td>Abstracted data access</td>
                    </tr>
                    <tr>
                        <td><strong>Strategy Pattern</strong></td>
                        <td>Monitoring modes (snapshot vs live)</td>
                        <td>Runtime behavior switching</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <div class="highlight">
            <h3>ğŸ“Œ Important Notes</h3>
            <ul>
                <li>SimpleMonitoringServer (port 8091) is the "perfect" production-ready version</li>
                <li>WebSocket server must be running for live mode functionality</li>
                <li>Database connection is optional - falls back to sample data if unavailable</li>
                <li>All state machines must implement <code>StateMachineContextEntity</code> for persistence</li>
                <li>Registry mediates all events to ensure proper monitoring and persistence</li>
            </ul>
        </div>

        <div class="section">
            <h2>ğŸ”— Quick Command Reference</h2>
            <pre><code># Start monitoring system
./monitor-start.sh

# Compile project
mvn compile

# Run CLI monitor
mvn exec:java -Dexec.mainClass="com.telcobright.statemachine.monitoring.cli.StateMachineCliMonitor"

# Access web interface
http://localhost:8091

# WebSocket endpoint
ws://localhost:9999</code></pre>
        </div>

        <footer style="margin-top: 50px; padding-top: 20px; border-top: 1px solid #dee2e6; text-align: center; color: #6c757d;">
            <p>TelcoBright State Machine Library - Complete Technical Documentation</p>
            <p>Last Updated: 2024 | Version: 1.0</p>
        </footer>
    </div>
</body>
</html>