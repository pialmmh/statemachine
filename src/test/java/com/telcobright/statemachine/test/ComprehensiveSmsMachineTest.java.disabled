package com.telcobright.statemachine.test;

import com.telcobright.statemachine.GenericStateMachine;
import com.telcobright.statemachine.StateMachineRegistry;
import com.telcobright.statemachine.FluentStateMachineBuilder;
import com.telcobright.statemachine.events.TimeoutEvent;
import com.telcobright.statemachineexamples.smsmachine.entity.SmsEntity;
import com.telcobright.statemachineexamples.smsmachine.context.SmsContext;
import com.telcobright.statemachineexamples.smsmachine.SmsMachine;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;

import java.sql.ResultSet;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.HashMap;

/**
 * Comprehensive Test Suite for SmsMachine
 * Tests all aspects including high-volume processing, date partitioning, and retry logic
 */
public class ComprehensiveSmsMachineTest {
    
    private TestDatabaseManager dbManager;
    private ObjectMapper jsonMapper;
    private String testRunId;
    private List<TestResult> testResults;
    
    public ComprehensiveSmsMachineTest() throws Exception {
        this.dbManager = new TestDatabaseManager();
        this.jsonMapper = new ObjectMapper();
        this.testRunId = "SMS_TEST_" + LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss"));
        this.testResults = new ArrayList<>();
        
        System.out.println("üì± === COMPREHENSIVE SMS MACHINE TESTING ===");
        System.out.println("Test Run ID: " + testRunId);
        System.out.println("Database: " + dbManager.getDatabaseInfo());
        System.out.println("Started at: " + LocalDateTime.now());
        System.out.println("‚ïê".repeat(60));
    }
    
    /**
     * Test 1: SMS Machine Initialization Tests
     */
    public void testSmsInitialization() {
        System.out.println("\nüìã TEST 1: SMS Machine Initialization");
        System.out.println("‚îÄ".repeat(40));
        
        TestResult result = new TestResult("testSmsInitialization", "SMS_MACHINE");
        
        try {
            // Test 1.1: Basic SMS machine creation
            String machineId = testRunId + "_sms_init_basic";
            StateMachineRegistry registry = new StateMachineRegistry();
GenericStateMachine<SmsEntity, SmsContext> machine = registry.create(machineId, () -> SmsMachine.create(machineId));
            
            result.addAssertion("SMS machine created successfully", machine != null);
            result.addAssertion("Initial state is QUEUED", "QUEUED".equals(machine.getCurrentState()));
            result.addAssertion("Machine ID matches", machineId.equals(machine.getId()));
            
            // Test 1.2: SMS machine with context
            SmsContext context = new SmsContext("SMS-INIT-001", "+1234567890", "+0987654321", "Test initialization message");
            machine.setContext(context);
            
            result.addAssertion("Context set successfully", machine.getContext() != null);
            result.addAssertion("Context data preserved", context.getMessageId().equals(machine.getContext().getMessageId()));
            result.addAssertion("Message text preserved", "Test initialization message".equals(machine.getContext().getMessageText()));
            
            // Test 1.3: SMS with persistent entity
            SmsEntity entity = new SmsEntity();
            entity.setSmsId(machineId);
            entity.setCurrentState("QUEUED");
            entity.setFromNumber("+1234567890");
            entity.setToNumber("+0987654321");
            entity.setMessageText("Test initialization message");
            machine.setPersistingEntity(entity);
            
            result.addAssertion("Persistent entity set", machine.getPersistingEntity() != null);
            result.addAssertion("Entity ID matches machine ID", machineId.equals(machine.getPersistingEntity().getSmsId()));
            
            // Save snapshot of initialized state
            saveStateSnapshot(machineId, "SMS", "QUEUED", entity, context, "INITIALIZATION", "SMS machine successfully initialized");
            
            System.out.println("‚úÖ Basic SMS initialization: SUCCESS");
            
            // Test 1.4: High-volume SMS creation with timestamp IDs
            List<GenericStateMachine<SmsEntity, SmsContext>> smsMachines = new ArrayList<>();
            for (int i = 1; i <= 10; i++) {
                long timestampId = com.telcobright.idkit.IdGenerator.generateId();
                String smsId = String.valueOf(timestampId);
                GenericStateMachine<SmsEntity, SmsContext> sms = SmsMachine.create(smsId);
                
                SmsContext smsContext = new SmsContext("SMS-BULK-" + String.format("%03d", i), 
                    "+123456789" + (i % 10), "+098765432" + (i % 10), "Bulk test message " + i);
                sms.setContext(smsContext);
                smsMachines.add(sms);
                
                // Verify timestamp ID format
                result.addAssertion("Timestamp ID format valid (SMS " + i + ")", 
                    smsId.length() > 10 && Long.parseLong(smsId) > 0);
            }
            
            result.addAssertion("High-volume SMS machines created", smsMachines.size() == 10);
            result.addAssertion("All SMS machines have unique timestamp IDs", 
                smsMachines.stream().map(m -> m.getId()).distinct().count() == 10);
            
            System.out.println("‚úÖ High-volume initialization: SUCCESS");
            
            result.setStatus("PASSED");
            
        } catch (Exception e) {
            result.setStatus("FAILED");
            result.setErrorMessage(e.getMessage());
            System.out.println("‚ùå SMS initialization test failed: " + e.getMessage());
            e.printStackTrace();
        }
        
        testResults.add(result);
        logTestResult(result);
    }
    
    /**
     * Test 2: Basic SMS Flow Tests
     */
    public void testBasicSmsFlow() {
        System.out.println("\nüì§ TEST 2: Basic SMS Flow");
        System.out.println("‚îÄ".repeat(40));
        
        TestResult result = new TestResult("testBasicSmsFlow", "SMS_MACHINE");
        
        try {
            long timestampId = com.telcobright.idkit.IdGenerator.generateId();
            String machineId = String.valueOf(timestampId);
            StateMachineRegistry registry = new StateMachineRegistry();
GenericStateMachine<SmsEntity, SmsContext> machine = registry.create(machineId, () -> SmsMachine.create(machineId));
            
            SmsContext context = new SmsContext("SMS-FLOW-001", "+1234567890", "+0987654321", "Hello! This is a basic test SMS message.");
            SmsEntity entity = createSmsEntity(machineId, "+1234567890", "+0987654321", "Hello! This is a basic test SMS message.");
            machine.setContext(context);
            machine.setPersistingEntity(entity);
            
            // Initial state check
            result.addAssertion("Initial state is QUEUED", "QUEUED".equals(machine.getCurrentState()));
            result.addAssertion("Message is queued", "PENDING".equals(context.getMessageStatus()));
            saveStateSnapshot(machineId, "SMS", machine.getCurrentState(), entity, context, "INITIAL", "SMS flow starting");
            
            // Step 1: Send attempt
            System.out.println("üì® Step 1: Send attempt initiated");
            machine.fire(new SendAttempt());
            
            result.addAssertion("State transitioned to SENDING", "SENDING".equals(machine.getCurrentState()));
            result.addAssertion("Attempt count increased", context.getAttemptCount() > 0);
            saveStateSnapshot(machineId, "SMS", machine.getCurrentState(), entity, context, "SendAttempt", "SMS sending initiated");
            
            // Step 2: Status updates during sending
            Thread.sleep(500);
            System.out.println("üìä Step 2: Status updates during sending");
            machine.fire(new StatusUpdate("Gateway processing message"));
            
            result.addAssertion("State remains SENDING after status update", "SENDING".equals(machine.getCurrentState()));
            result.addAssertion("Delivery events recorded", !context.getDeliveryEvents().isEmpty());
            saveStateSnapshot(machineId, "SMS", machine.getCurrentState(), entity, context, "StatusUpdate", "Status update received");
            
            Thread.sleep(300);
            machine.fire(new StatusUpdate("Message routed to carrier"));
            saveStateSnapshot(machineId, "SMS", machine.getCurrentState(), entity, context, "StatusUpdate", "Second status update");
            
            // Step 3: Delivery report
            Thread.sleep(1000);
            System.out.println("‚úÖ Step 3: Delivery report received");
            machine.fire(new DeliveryReport());
            
            result.addAssertion("State transitioned to DELIVERED", "DELIVERED".equals(machine.getCurrentState()));
            result.addAssertion("Message marked as delivered", context.getDeliveryTime().toSeconds() > 0);
            result.addAssertion("Final delivery event recorded", 
                context.getDeliveryEvents().stream().anyMatch(event -> event.contains("delivered")));
            saveStateSnapshot(machineId, "SMS", machine.getCurrentState(), entity, context, "DeliveryReport", "SMS delivered successfully");
            
            System.out.println("‚úÖ Basic SMS flow: SUCCESS");
            System.out.println("   Delivery time: " + context.getDeliveryTime().toSeconds() + "s");
            System.out.println("   Attempt count: " + context.getAttemptCount());
            System.out.println("   Priority: " + context.getPriority());
            
            result.setStatus("PASSED");
            
        } catch (Exception e) {
            result.setStatus("FAILED");
            result.setErrorMessage(e.getMessage());
            System.out.println("‚ùå Basic SMS flow test failed: " + e.getMessage());
            e.printStackTrace();
        }
        
        testResults.add(result);
        logTestResult(result);
    }
    
    /**
     * Test 3: Advanced SMS Scenarios
     */
    public void testAdvancedSmsScenarios() {
        System.out.println("\nüé≠ TEST 3: Advanced SMS Scenarios");
        System.out.println("‚îÄ".repeat(40));
        
        // Test 3.1: High priority SMS
        testHighPriorityMessage();
        
        // Test 3.2: Long message segmentation
        testLongMessageHandling();
        
        // Test 3.3: SMS with retry logic
        testRetryLogic();
        
        // Test 3.4: Emergency SMS processing
        testEmergencyMessage();
        
        // Test 3.5: Bulk SMS processing
        testBulkSmsProcessing();
    }
    
    private void testHighPriorityMessage() {
        TestResult result = new TestResult("testHighPriorityMessage", "SMS_MACHINE");
        
        try {
            long timestampId = com.telcobright.idkit.IdGenerator.generateId();
            String machineId = String.valueOf(timestampId);
            StateMachineRegistry registry = new StateMachineRegistry();
GenericStateMachine<SmsEntity, SmsContext> machine = registry.create(machineId, () -> SmsMachine.create(machineId));
            
            SmsContext context = new SmsContext("SMS-HIPRI-001", "+1800911911", "+0987654321", "URGENT: Emergency alert notification");
            SmsEntity entity = createSmsEntity(machineId, "+1800911911", "+0987654321", "URGENT: Emergency alert notification");
            entity.setPriority("HIGH");
            
            machine.setContext(context);
            machine.setPersistingEntity(entity);
            
            System.out.println("üö® Testing high priority message");
            
            result.addAssertion("Message detected as high priority", context.isHighPriority());
            
            // Full flow with priority handling
            machine.fire(new SendAttempt());
            saveStateSnapshot(machineId, "SMS", machine.getCurrentState(), entity, context, "SendAttempt", "High priority SMS sending");
            
            Thread.sleep(200); // High priority = faster processing
            machine.fire(new StatusUpdate("Priority message - expedited routing"));
            saveStateSnapshot(machineId, "SMS", machine.getCurrentState(), entity, context, "StatusUpdate", "Priority status update");
            
            Thread.sleep(300);
            machine.fire(new DeliveryReport());
            saveStateSnapshot(machineId, "SMS", machine.getCurrentState(), entity, context, "DeliveryReport", "Priority SMS delivered");
            
            result.addAssertion("High priority SMS delivered", "DELIVERED".equals(machine.getCurrentState()));
            result.addAssertion("Fast delivery time", context.getDeliveryTime().toSeconds() < 5);
            result.setStatus("PASSED");
            
            System.out.println("‚úÖ High priority message: SUCCESS");
            
        } catch (Exception e) {
            result.setStatus("FAILED");
            result.setErrorMessage(e.getMessage());
            System.out.println("‚ùå High priority message test failed: " + e.getMessage());
        }
        
        testResults.add(result);
        logTestResult(result);
    }
    
    private void testLongMessageHandling() {
        TestResult result = new TestResult("testLongMessageHandling", "SMS_MACHINE");
        
        try {
            long timestampId = com.telcobright.idkit.IdGenerator.generateId();
            String machineId = String.valueOf(timestampId);
            StateMachineRegistry registry = new StateMachineRegistry();
GenericStateMachine<SmsEntity, SmsContext> machine = registry.create(machineId, () -> SmsMachine.create(machineId));
            
            String longMessage = "This is a very long SMS message that exceeds the normal 160 character limit and will need to be segmented into multiple parts for delivery across the SMS network infrastructure. This message is intentionally long to test the system's handling of multi-part SMS messages and ensure proper delivery and tracking of segmented messages across different carriers and networks.";
            
            SmsContext context = new SmsContext("SMS-LONG-001", "+1555123456", "+0987654321", longMessage);
            SmsEntity entity = createSmsEntity(machineId, "+1555123456", "+0987654321", longMessage);
            
            machine.setContext(context);
            machine.setPersistingEntity(entity);
            
            System.out.println("üìÑ Testing long message handling");
            System.out.println("   Message length: " + longMessage.length() + " characters");
            
            result.addAssertion("Message detected as long", context.isLongMessage());
            result.addAssertion("Message exceeds 160 chars", longMessage.length() > 160);
            
            machine.fire(new SendAttempt());
            saveStateSnapshot(machineId, "SMS", machine.getCurrentState(), entity, context, "SendAttempt", "Long message sending");
            
            Thread.sleep(500);
            machine.fire(new StatusUpdate("Message segmented - sending part 1 of 3"));
            Thread.sleep(300);
            machine.fire(new StatusUpdate("Message segmented - sending part 2 of 3"));
            Thread.sleep(300);
            machine.fire(new StatusUpdate("Message segmented - sending part 3 of 3"));
            saveStateSnapshot(machineId, "SMS", machine.getCurrentState(), entity, context, "StatusUpdate", "Segmented message progress");
            
            Thread.sleep(800);
            machine.fire(new DeliveryReport());
            saveStateSnapshot(machineId, "SMS", machine.getCurrentState(), entity, context, "DeliveryReport", "Long message delivered");
            
            result.addAssertion("Long message delivered", "DELIVERED".equals(machine.getCurrentState()));
            result.addAssertion("Segmentation events recorded", 
                context.getDeliveryEvents().stream().anyMatch(event -> event.contains("segmented")));
            result.setStatus("PASSED");
            
            System.out.println("‚úÖ Long message handling: SUCCESS");
            
        } catch (Exception e) {
            result.setStatus("FAILED");
            result.setErrorMessage(e.getMessage());
            System.out.println("‚ùå Long message test failed: " + e.getMessage());
        }
        
        testResults.add(result);
        logTestResult(result);
    }
    
    private void testRetryLogic() {
        TestResult result = new TestResult("testRetryLogic", "SMS_MACHINE");
        
        try {
            long timestampId = com.telcobright.idkit.IdGenerator.generateId();
            String machineId = String.valueOf(timestampId);
            StateMachineRegistry registry = new StateMachineRegistry();
GenericStateMachine<SmsEntity, SmsContext> machine = registry.create(machineId, () -> SmsMachine.create(machineId));
            
            SmsContext context = new SmsContext("SMS-RETRY-001", "+1999888777", "+0987654321", "Test message with retry logic");
            SmsEntity entity = createSmsEntity(machineId, "+1999888777", "+0987654321", "Test message with retry logic");
            
            machine.setContext(context);
            machine.setPersistingEntity(entity);
            
            System.out.println("üîÑ Testing SMS retry logic");
            
            // First attempt
            machine.fire(new SendAttempt());
            saveStateSnapshot(machineId, "SMS", machine.getCurrentState(), entity, context, "SendAttempt", "First send attempt");
            
            Thread.sleep(500);
            // Simulate failure
            machine.fire(new SendFailed());
            saveStateSnapshot(machineId, "SMS", machine.getCurrentState(), entity, context, "SendFailed", "First attempt failed");
            
            result.addAssertion("State transitioned to FAILED", "FAILED".equals(machine.getCurrentState()));
            result.addAssertion("Can retry", context.canRetry());
            
            // Retry attempt
            Thread.sleep(1000);
            machine.fire(new Retry());
            saveStateSnapshot(machineId, "SMS", machine.getCurrentState(), entity, context, "Retry", "Retry initiated");
            
            result.addAssertion("State back to QUEUED for retry", "QUEUED".equals(machine.getCurrentState()));
            
            // Second attempt
            machine.fire(new SendAttempt());
            saveStateSnapshot(machineId, "SMS", machine.getCurrentState(), entity, context, "SendAttempt", "Second send attempt");
            
            Thread.sleep(500);
            machine.fire(new StatusUpdate("Retry attempt successful"));
            Thread.sleep(500);
            machine.fire(new DeliveryReport());
            saveStateSnapshot(machineId, "SMS", machine.getCurrentState(), entity, context, "DeliveryReport", "Retry successful - delivered");
            
            result.addAssertion("Retry successful", "DELIVERED".equals(machine.getCurrentState()));
            result.addAssertion("Multiple attempts recorded", context.getAttemptCount() > 1);
            result.setStatus("PASSED");
            
            System.out.println("‚úÖ Retry logic: SUCCESS");
            System.out.println("   Final attempt count: " + context.getAttemptCount());
            
        } catch (Exception e) {
            result.setStatus("FAILED");
            result.setErrorMessage(e.getMessage());
            System.out.println("‚ùå Retry logic test failed: " + e.getMessage());
        }
        
        testResults.add(result);
        logTestResult(result);
    }
    
    private void testEmergencyMessage() {
        TestResult result = new TestResult("testEmergencyMessage", "SMS_MACHINE");
        
        try {
            long timestampId = com.telcobright.idkit.IdGenerator.generateId();
            String machineId = String.valueOf(timestampId);
            StateMachineRegistry registry = new StateMachineRegistry();
GenericStateMachine<SmsEntity, SmsContext> machine = registry.create(machineId, () -> SmsMachine.create(machineId));
            
            SmsContext context = new SmsContext("SMS-EMRG-001", "+1911911911", "+0987654321", "EMERGENCY: Immediate assistance required");
            SmsEntity entity = createSmsEntity(machineId, "+1911911911", "+0987654321", "EMERGENCY: Immediate assistance required");
            entity.setPriority("EMERGENCY");
            
            machine.setContext(context);
            machine.setPersistingEntity(entity);
            
            System.out.println("üö® Testing emergency message handling");
            
            result.addAssertion("Emergency message detected", context.isEmergencyMessage());
            result.addAssertion("Priority set to emergency", "EMERGENCY".equals(entity.getPriority()));
            
            // Emergency messages get immediate processing
            machine.fire(new SendAttempt());
            saveStateSnapshot(machineId, "SMS", machine.getCurrentState(), entity, context, "SendAttempt", "Emergency SMS sending");
            
            Thread.sleep(100); // Very fast processing for emergency
            machine.fire(new StatusUpdate("EMERGENCY - Highest priority routing"));
            Thread.sleep(100);
            machine.fire(new DeliveryReport());
            saveStateSnapshot(machineId, "SMS", machine.getCurrentState(), entity, context, "DeliveryReport", "Emergency SMS delivered");
            
            result.addAssertion("Emergency SMS delivered quickly", "DELIVERED".equals(machine.getCurrentState()));
            result.addAssertion("Very fast delivery", context.getDeliveryTime().toSeconds() < 2);
            result.setStatus("PASSED");
            
            System.out.println("‚úÖ Emergency message: SUCCESS");
            
        } catch (Exception e) {
            result.setStatus("FAILED");
            result.setErrorMessage(e.getMessage());
            System.out.println("‚ùå Emergency message test failed: " + e.getMessage());
        }
        
        testResults.add(result);
        logTestResult(result);
    }
    
    private void testBulkSmsProcessing() {
        TestResult result = new TestResult("testBulkSmsProcessing", "SMS_MACHINE");
        
        try {
            System.out.println("üìä Testing bulk SMS processing");
            
            List<GenericStateMachine<SmsEntity, SmsContext>> bulkMachines = new ArrayList<>();
            int bulkSize = 20;
            
            for (int i = 1; i <= bulkSize; i++) {
                long timestampId = com.telcobright.idkit.IdGenerator.generateId();
                String machineId = String.valueOf(timestampId);
                StateMachineRegistry registry = new StateMachineRegistry();
GenericStateMachine<SmsEntity, SmsContext> machine = registry.create(machineId, () -> SmsMachine.create(machineId));
                
                SmsContext context = new SmsContext("SMS-BULK-" + String.format("%03d", i), 
                    "+1234567890", "+098765432" + (i % 10), 
                    "Bulk message #" + i + " for testing high-volume processing");
                SmsEntity entity = createSmsEntity(machineId, "+1234567890", "+098765432" + (i % 10), 
                    "Bulk message #" + i + " for testing high-volume processing");
                
                machine.setContext(context);
                machine.setPersistingEntity(entity);
                bulkMachines.add(machine);
                
                // Process each SMS
                machine.fire(new SendAttempt());
                Thread.sleep(50); // Simulate realistic processing delay
                machine.fire(new DeliveryReport());
                
                saveStateSnapshot(machineId, "SMS", machine.getCurrentState(), entity, context, 
                    "BulkProcessing", "Bulk SMS #" + i + " processed");
            }
            
            result.addAssertion("All bulk messages created", bulkMachines.size() == bulkSize);
            
            // Verify all were delivered
            long deliveredCount = bulkMachines.stream()
                .mapToLong(m -> "DELIVERED".equals(m.getCurrentState()) ? 1 : 0)
                .sum();
            
            result.addAssertion("All bulk messages delivered", deliveredCount == bulkSize);
            result.addAssertion("Unique timestamp IDs", bulkMachines.stream()
                .map(m -> m.getId()).distinct().count() == bulkSize);
            
            result.setStatus("PASSED");
            System.out.println("‚úÖ Bulk SMS processing: SUCCESS (" + bulkSize + " messages)");
            
        } catch (Exception e) {
            result.setStatus("FAILED");
            result.setErrorMessage(e.getMessage());
            System.out.println("‚ùå Bulk SMS processing test failed: " + e.getMessage());
        }
        
        testResults.add(result);
        logTestResult(result);
    }
    
    /**
     * Test 4: Timeout Tests
     */
    public void testSmsTimeoutScenarios() {
        System.out.println("\n‚è∞ TEST 4: SMS Timeout Scenarios");
        System.out.println("‚îÄ".repeat(40));
        
        TestResult result = new TestResult("testSmsTimeoutScenarios", "TIMEOUT");
        
        try {
            long timestampId = com.telcobright.idkit.IdGenerator.generateId();
            String machineId = String.valueOf(timestampId);
            StateMachineRegistry registry = new StateMachineRegistry();
GenericStateMachine<SmsEntity, SmsContext> machine = registry.create(machineId, () -> SmsMachine.create(machineId));
            
            SmsContext context = new SmsContext("SMS-TIMEOUT-001", "+1777888999", "+0987654321", "Test message for timeout scenario");
            SmsEntity entity = createSmsEntity(machineId, "+1777888999", "+0987654321", "Test message for timeout scenario");
            
            machine.setContext(context);
            machine.setPersistingEntity(entity);
            
            System.out.println("‚è≥ Testing SMS delivery timeout");
            
            machine.fire(new SendAttempt());
            saveStateSnapshot(machineId, "SMS", machine.getCurrentState(), entity, context, "SendAttempt", "SMS sending - testing timeout");
            
            result.addAssertion("SMS is sending", "SENDING".equals(machine.getCurrentState()));
            
            // Wait for timeout (simulate 30-second delivery timeout)
            CountDownLatch timeoutLatch = new CountDownLatch(1);
            
            // Set up timeout callback
            machine.setOnStateTransition(newState -> {
                if ("FAILED".equals(newState)) {
                    timeoutLatch.countDown();
                }
            });
            
            // Simulate timeout event
            Thread.sleep(2000); // Shortened for testing
            machine.fire(new TimeoutEvent("SENDING", "FAILED"));
            
            boolean timedOut = timeoutLatch.await(5, TimeUnit.SECONDS);
            result.addAssertion("Timeout occurred", timedOut);
            result.addAssertion("SMS failed due to timeout", "FAILED".equals(machine.getCurrentState()));
            
            saveStateSnapshot(machineId, "SMS", machine.getCurrentState(), entity, context, "TimeoutEvent", "SMS failed due to delivery timeout");
            
            result.addAssertion("Timeout reason recorded", 
                context.getFailureReason() != null && context.getFailureReason().contains("timeout"));
            
            // Test retry after timeout
            if (context.canRetry()) {
                Thread.sleep(1000);
                machine.fire(new Retry());
                saveStateSnapshot(machineId, "SMS", machine.getCurrentState(), entity, context, "Retry", "Retry after timeout");
                
                result.addAssertion("Can retry after timeout", "QUEUED".equals(machine.getCurrentState()));
            }
            
            result.setStatus("PASSED");
            System.out.println("‚úÖ SMS timeout scenario: SUCCESS");
            
        } catch (Exception e) {
            result.setStatus("FAILED");
            result.setErrorMessage(e.getMessage());
            System.out.println("‚ùå SMS timeout test failed: " + e.getMessage());
            e.printStackTrace();
        }
        
        testResults.add(result);
        logTestResult(result);
    }
    
    /**
     * Test 5: Persistence Verification
     */
    public void testSmsPersistenceVerification() {
        System.out.println("\nüíæ TEST 5: SMS Persistence Verification");
        System.out.println("‚îÄ".repeat(40));
        
        TestResult result = new TestResult("testSmsPersistenceVerification", "PERSISTENCE");
        
        try {
            long timestampId = com.telcobright.idkit.IdGenerator.generateId();
            String machineId = String.valueOf(timestampId);
            StateMachineRegistry registry = new StateMachineRegistry();
GenericStateMachine<SmsEntity, SmsContext> machine = registry.create(machineId, () -> SmsMachine.create(machineId));
            
            System.out.println("üíø Testing SMS persistence with timestamp ID: " + timestampId);
            System.out.println("   Extracted timestamp: " + com.telcobright.idkit.IdGenerator.extractTimestampLocal(timestampId));
            
            SmsContext context = new SmsContext("SMS-PERSIST-001", "+1999000111", "+0987654321", "Test message for persistence verification");
            SmsEntity entity = createSmsEntity(machineId, "+1999000111", "+0987654321", "Test message for persistence verification");
            
            machine.setContext(context);
            machine.setPersistingEntity(entity);
            
            // Execute full SMS flow and verify persistence at each step
            String[] expectedStates = {"QUEUED", "SENDING", "DELIVERED"};
            String[] events = {"INITIAL", "SendAttempt", "DeliveryReport"};
            
            for (int i = 0; i < expectedStates.length; i++) {
                String expectedState = expectedStates[i];
                String event = events[i];
                
                // Execute event (except for initial state)
                if (i > 0) {
                    switch (event) {
                        case "SendAttempt":
                            machine.fire(new SendAttempt());
                            break;
                        case "DeliveryReport":
                            Thread.sleep(1000);
                            machine.fire(new StatusUpdate("Gateway confirmed delivery"));
                            Thread.sleep(500);
                            machine.fire(new DeliveryReport());
                            break;
                    }
                }
                
                // Verify state
                result.addAssertion("State is " + expectedState, expectedState.equals(machine.getCurrentState()));
                
                // Save snapshot
                saveStateSnapshot(machineId, "SMS", machine.getCurrentState(), entity, context, event, 
                    "Persistence test - step " + (i + 1));
                
                // Verify persistence by reading back
                Thread.sleep(100); // Small delay for DB write
                try (ResultSet snapshots = dbManager.getSnapshots(testRunId, machineId, "SMS")) {
                    int snapshotCount = 0;
                    while (snapshots.next()) {
                        snapshotCount++;
                    }
                    result.addAssertion("Snapshots persisted correctly (step " + (i + 1) + ")", snapshotCount == (i + 1));
                }
                
                System.out.println("  ‚úì Step " + (i + 1) + ": " + expectedState + " - persisted");
            }
            
            // Test timestamp-based querying (ByIdAndDateRange feature)
            String timestampQuery = "SELECT * FROM sms_state_snapshots WHERE test_run_id = ? AND sms_id = ? AND transition_timestamp >= ?";
            try (ResultSet timestampResults = dbManager.executeQuery(timestampQuery, testRunId, machineId, 
                com.telcobright.idkit.IdGenerator.extractTimestamp(timestampId))) {
                int timestampMatches = 0;
                while (timestampResults.next()) {
                    timestampMatches++;
                }
                result.addAssertion("Timestamp-based queries work", timestampMatches > 0);
            }
            
            // Verify complete persistence integrity
            boolean integrityValid = dbManager.validateStateMachineIntegrity(testRunId, "SMS");
            result.addAssertion("SMS state machine integrity valid", integrityValid);
            
            result.setStatus("PASSED");
            System.out.println("‚úÖ SMS persistence verification: SUCCESS");
            
        } catch (Exception e) {
            result.setStatus("FAILED");
            result.setErrorMessage(e.getMessage());
            System.out.println("‚ùå SMS persistence test failed: " + e.getMessage());
            e.printStackTrace();
        }
        
        testResults.add(result);
        logTestResult(result);
    }
    
    /**
     * Test 6: Full SMS Lifecycle with Snapshots
     */
    public void testFullSmsLifecycleWithSnapshots() {
        System.out.println("\nüîÑ TEST 6: Full SMS Lifecycle with Snapshots");
        System.out.println("‚îÄ".repeat(40));
        
        TestResult result = new TestResult("testFullSmsLifecycleWithSnapshots", "SMS_MACHINE");
        
        try {
            long timestampId = com.telcobright.idkit.IdGenerator.generateId();
            String machineId = String.valueOf(timestampId);
            StateMachineRegistry registry = new StateMachineRegistry();
GenericStateMachine<SmsEntity, SmsContext> machine = registry.create(machineId, () -> SmsMachine.create(machineId));
            
            SmsContext context = new SmsContext("SMS-LIFECYCLE-001", "+1123581321", "+0987654321", 
                "Comprehensive lifecycle test message for detailed snapshot analysis");
            SmsEntity entity = createSmsEntity(machineId, "+1123581321", "+0987654321", 
                "Comprehensive lifecycle test message for detailed snapshot analysis");
            
            machine.setContext(context);
            machine.setPersistingEntity(entity);
            
            System.out.println("üì∏ Capturing detailed snapshots throughout SMS lifecycle");
            System.out.println("   Message length: " + context.getMessageText().length() + " chars");
            System.out.println("   Timestamp ID: " + timestampId);
            
            Map<String, Map<String, Object>> stateSnapshots = new HashMap<>();
            
            // Initial state snapshot
            captureDetailedSnapshot(stateSnapshots, "INITIAL", machine, entity, context);
            
            // Step 1: Send attempt
            System.out.println("  üì§ Initiating send attempt...");
            machine.fire(new SendAttempt());
            Thread.sleep(300);
            captureDetailedSnapshot(stateSnapshots, "SENDING_INITIAL", machine, entity, context);
            
            // Step 2: Multiple status updates
            System.out.println("  üìä Processing status updates...");
            machine.fire(new StatusUpdate("Message received by gateway"));
            Thread.sleep(200);
            captureDetailedSnapshot(stateSnapshots, "SENDING_GATEWAY", machine, entity, context);
            
            machine.fire(new StatusUpdate("Message routed to carrier"));
            Thread.sleep(300);
            captureDetailedSnapshot(stateSnapshots, "SENDING_CARRIER", machine, entity, context);
            
            machine.fire(new StatusUpdate("Message delivered to handset"));
            Thread.sleep(200);
            captureDetailedSnapshot(stateSnapshots, "SENDING_HANDSET", machine, entity, context);
            
            // Step 3: Delivery confirmation
            System.out.println("  ‚úÖ Delivery confirmation...");
            machine.fire(new DeliveryReport());
            Thread.sleep(100);
            captureDetailedSnapshot(stateSnapshots, "DELIVERED_FINAL", machine, entity, context);
            
            // Verify all snapshots
            result.addAssertion("All snapshots captured", stateSnapshots.size() == 5);
            
            // Verify context evolution
            Map<String, Object> initialSnapshot = stateSnapshots.get("INITIAL");
            Map<String, Object> finalSnapshot = stateSnapshots.get("DELIVERED_FINAL");
            
            result.addAssertion("Delivery time increased", 
                (Long) finalSnapshot.get("deliveryTimeSeconds") > (Long) initialSnapshot.get("deliveryTimeSeconds"));
            result.addAssertion("Attempt count increased", 
                (Integer) finalSnapshot.get("attemptCount") > (Integer) initialSnapshot.get("attemptCount"));
            result.addAssertion("Delivery events recorded", 
                ((List<?>) finalSnapshot.get("deliveryEvents")).size() > ((List<?>) initialSnapshot.get("deliveryEvents")).size());
            
            // Verify persistent entity evolution
            result.addAssertion("Entity state updated", "DELIVERED".equals(finalSnapshot.get("entityCurrentState")));
            result.addAssertion("Entity message status updated", finalSnapshot.get("entityMessageStatus") != null);
            
            // Verify message characteristics were preserved
            result.addAssertion("Message text preserved", 
                initialSnapshot.get("messageLength").equals(finalSnapshot.get("messageLength")));
            result.addAssertion("Priority maintained", 
                initialSnapshot.get("priority").equals(finalSnapshot.get("priority")));
            
            System.out.println("‚úÖ Full SMS lifecycle with snapshots: SUCCESS");
            System.out.println("   Total snapshots: " + stateSnapshots.size());
            System.out.println("   Final delivery time: " + finalSnapshot.get("deliveryTimeSeconds") + "s");
            System.out.println("   Final attempt count: " + finalSnapshot.get("attemptCount"));
            System.out.println("   Delivery events: " + ((List<?>) finalSnapshot.get("deliveryEvents")).size());
            
            result.setStatus("PASSED");
            
        } catch (Exception e) {
            result.setStatus("FAILED");
            result.setErrorMessage(e.getMessage());
            System.out.println("‚ùå Full SMS lifecycle test failed: " + e.getMessage());
            e.printStackTrace();
        }
        
        testResults.add(result);
        logTestResult(result);
    }
    
    /**
     * Helper method to create SmsEntity
     */
    private SmsEntity createSmsEntity(String smsId, String fromNumber, String toNumber, String messageText) {
        SmsEntity entity = new SmsEntity();
        entity.setSmsId(smsId);
        entity.setCurrentState("QUEUED");
        entity.setFromNumber(fromNumber);
        entity.setToNumber(toNumber);
        entity.setMessageText(messageText);
        entity.setAttemptCount(0);
        entity.setMaxRetries(3);
        entity.setPriority(fromNumber.contains("911") ? "EMERGENCY" : 
                         (fromNumber.startsWith("+1800") ? "HIGH" : "NORMAL"));
        entity.setMessageStatus("PENDING");
        return entity;
    }
    
    /**
     * Save detailed SMS state snapshot
     */
    private void saveStateSnapshot(String machineId, String machineType, String stateName,
                                  SmsEntity entity, SmsContext context, String event, String notes) {
        try {
            ObjectNode persistentData = jsonMapper.createObjectNode();
            persistentData.put("smsId", entity.getSmsId());
            persistentData.put("currentState", entity.getCurrentState());
            persistentData.put("fromNumber", entity.getFromNumber());
            persistentData.put("toNumber", entity.getToNumber());
            persistentData.put("messageText", entity.getMessageText());
            persistentData.put("attemptCount", entity.getAttemptCount());
            persistentData.put("maxRetries", entity.getMaxRetries());
            persistentData.put("priority", entity.getPriority());
            persistentData.put("messageStatus", entity.getMessageStatus());
            
            ObjectNode volatileData = jsonMapper.createObjectNode();
            volatileData.put("messageId", context.getMessageId());
            volatileData.put("deliveryTimeSeconds", context.getDeliveryTime().toSeconds());
            volatileData.put("attemptCount", context.getAttemptCount());
            volatileData.put("priority", context.getPriority());
            volatileData.put("messageLength", context.getMessageText().length());
            volatileData.put("isLongMessage", context.isLongMessage());
            volatileData.put("isHighPriority", context.isHighPriority());
            volatileData.put("isEmergencyMessage", context.isEmergencyMessage());
            volatileData.put("canRetry", context.canRetry());
            volatileData.put("deliveryEventsCount", context.getDeliveryEvents().size());
            
            dbManager.saveStateSnapshot(testRunId, machineId, machineType, stateName, 
                persistentData.toString(), volatileData.toString(), event, notes);
            
        } catch (Exception e) {
            System.err.println("Failed to save SMS snapshot: " + e.getMessage());
        }
    }
    
    /**
     * Capture detailed snapshot for analysis
     */
    private void captureDetailedSnapshot(Map<String, Map<String, Object>> snapshots, String snapshotKey,
                                       GenericStateMachine<SmsEntity, SmsContext> machine,
                                       SmsEntity entity, SmsContext context) {
        Map<String, Object> snapshot = new HashMap<>();
        
        // Machine state
        snapshot.put("machineState", machine.getCurrentState());
        snapshot.put("machineId", machine.getId());
        
        // Persistent entity data
        snapshot.put("entityCurrentState", entity.getCurrentState());
        snapshot.put("entityMessageStatus", entity.getMessageStatus());
        snapshot.put("entityAttemptCount", entity.getAttemptCount());
        snapshot.put("entityPriority", entity.getPriority());
        snapshot.put("entityMaxRetries", entity.getMaxRetries());
        
        // Volatile context data
        snapshot.put("deliveryTimeSeconds", context.getDeliveryTime().toSeconds());
        snapshot.put("attemptCount", context.getAttemptCount());
        snapshot.put("priority", context.getPriority());
        snapshot.put("messageLength", context.getMessageText().length());
        snapshot.put("isLongMessage", context.isLongMessage());
        snapshot.put("isHighPriority", context.isHighPriority());
        snapshot.put("isEmergencyMessage", context.isEmergencyMessage());
        snapshot.put("canRetry", context.canRetry());
        snapshot.put("deliveryEvents", new ArrayList<>(context.getDeliveryEvents()));
        snapshot.put("failureReason", context.getFailureReason());
        
        // Timestamp
        snapshot.put("timestamp", System.currentTimeMillis());
        
        snapshots.put(snapshotKey, snapshot);
        
        // Also save to database
        try {
            saveStateSnapshot(machine.getId(), "SMS", machine.getCurrentState(), entity, context, 
                snapshotKey, "Detailed snapshot: " + snapshotKey);
        } catch (Exception e) {
            System.err.println("Failed to save detailed SMS snapshot: " + e.getMessage());
        }
    }
    
    /**
     * Log test result to database
     */
    private void logTestResult(TestResult result) {
        try {
            dbManager.logTestExecution(testRunId, "ComprehensiveSmsMachineTest", 
                result.getTestName(), result.getTestType(), result.getMachineId(),
                result.getStatus(), result.getErrorMessage(), 
                result.getTotalAssertions(), result.getPassedAssertions());
        } catch (Exception e) {
            System.err.println("Failed to log SMS test result: " + e.getMessage());
        }
    }
    
    /**
     * Run all SMS machine tests
     */
    public void runAllTests() {
        try {
            System.out.println("üöÄ Starting comprehensive SMS machine tests...");
            
            testSmsInitialization();
            testBasicSmsFlow();
            testAdvancedSmsScenarios();
            testSmsTimeoutScenarios();
            testSmsPersistenceVerification();
            testFullSmsLifecycleWithSnapshots();
            
            // Print final summary
            System.out.println("\nüìä === SMS MACHINE TEST SUMMARY ===");
            dbManager.printTestSummary(testRunId);
            
            // Validate overall integrity
            boolean overallIntegrity = dbManager.validateStateMachineIntegrity(testRunId, "SMS");
            System.out.println("üîç SMS state machine integrity: " + (overallIntegrity ? "‚úÖ VALID" : "‚ùå INVALID"));
            
            // Calculate success rate
            long passedTests = testResults.stream().filter(r -> "PASSED".equals(r.getStatus())).count();
            double successRate = (double) passedTests / testResults.size() * 100;
            
            System.out.println("üéØ Overall success rate: " + String.format("%.1f%%", successRate) + 
                " (" + passedTests + "/" + testResults.size() + " tests passed)");
            
            if (successRate == 100.0) {
                System.out.println("üéâ ALL SMS MACHINE TESTS PASSED!");
            } else {
                System.out.println("‚ö†Ô∏è Some tests failed - check logs for details");
            }
            
        } catch (Exception e) {
            System.err.println("‚ùå SMS test execution failed: " + e.getMessage());
            e.printStackTrace();
        } finally {
            try {
                dbManager.close();
            } catch (Exception e) {
                System.err.println("Failed to close database connection: " + e.getMessage());
            }
        }
    }
    
    /**
     * Main method to run SMS machine tests
     */
    public static void main(String[] args) {
        try {
            ComprehensiveSmsMachineTest test = new ComprehensiveSmsMachineTest();
            test.runAllTests();
        } catch (Exception e) {
            System.err.println("Failed to initialize SMS machine tests: " + e.getMessage());
            e.printStackTrace();
            System.exit(1);
        }
    }
    
    /**
     * Test result holder class
     */
    private static class TestResult {
        private String testName;
        private String testType;
        private String machineId;
        private String status = "RUNNING";
        private String errorMessage;
        private List<String> assertions = new ArrayList<>();
        private List<Boolean> assertionResults = new ArrayList<>();
        
        public TestResult(String testName, String testType) {
            this.testName = testName;
            this.testType = testType;
        }
        
        public void addAssertion(String description, boolean result) {
            assertions.add(description);
            assertionResults.add(result);
            System.out.println("    " + (result ? "‚úì" : "‚úó") + " " + description);
        }
        
        public int getTotalAssertions() { return assertions.size(); }
        public int getPassedAssertions() { return (int) assertionResults.stream().mapToInt(b -> b ? 1 : 0).sum(); }
        
        // Getters and setters
        public String getTestName() { return testName; }
        public String getTestType() { return testType; }
        public String getMachineId() { return machineId; }
        public void setMachineId(String machineId) { this.machineId = machineId; }
        public String getStatus() { return status; }
        public void setStatus(String status) { this.status = status; }
        public String getErrorMessage() { return errorMessage; }
        public void setErrorMessage(String errorMessage) { this.errorMessage = errorMessage; }
    }
}