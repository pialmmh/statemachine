package com.telcobright.statemachine.test;

import com.telcobright.core.annotation.Column;
import com.telcobright.core.annotation.Id;
import com.telcobright.core.annotation.Table;
import com.telcobright.statemachine.StateMachineContextEntity;
import com.telcobright.statemachine.StateMachineRegistry;
import com.telcobright.statemachine.GenericStateMachine;
import com.telcobright.statemachine.EnhancedFluentBuilder;
import com.telcobright.statemachine.history.HistoryArchivalManager;
import com.telcobright.statemachine.timeout.TimeoutManager;
import com.telcobright.splitverse.config.RepositoryMode;
import com.telcobright.splitverse.config.ShardConfig;
import com.telcobright.statewalk.persistence.EntityGraphMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.sql.*;
import java.time.LocalDateTime;
import java.util.concurrent.TimeUnit;

/**
 * Comprehensive integration test for history archival feature
 *
 * Tests:
 * 1. Automatic archival when machines reach final states
 * 2. Startup scan to move existing finished machines
 * 3. Verification of data in history database
 * 4. Retention cleanup functionality
 */
public class HistoryArchivalIntegrationTest {

    private static final Logger log = LoggerFactory.getLogger(HistoryArchivalIntegrationTest.class);

    private static final String REGISTRY_ID = "test-archival-registry";
    private static final String ACTIVE_DB = REGISTRY_ID;
    private static final String HISTORY_DB = REGISTRY_ID + "-history";

    private static final String DB_HOST = "127.0.0.1";
    private static final int DB_PORT = 3306;
    private static final String DB_USER = "root";
    private static final String DB_PASSWORD = "123456";

    // Test context entity
    @Table(name = "call_contexts")
    public static class CallContext implements StateMachineContextEntity<CallContext> {

        @Id(autoGenerated = false)
        @Column(name = "id")
        private String id;

        @com.telcobright.core.annotation.ShardingKey
        @Column(name = "created_at")
        private LocalDateTime createdAt;

        @Column(name = "current_state")
        private String currentState;

        @Column(name = "last_state_change")
        private LocalDateTime lastStateChange;

        @Column(name = "caller_number")
        private String callerNumber;

        @Column(name = "callee_number")
        private String calleeNumber;

        @Column(name = "is_complete")
        private boolean isComplete = false;

        public CallContext() {
            this.createdAt = LocalDateTime.now();
            this.lastStateChange = LocalDateTime.now();
        }

        public CallContext(String id, String callerNumber, String calleeNumber) {
            this();
            this.id = id;
            this.callerNumber = callerNumber;
            this.calleeNumber = calleeNumber;
            this.currentState = "IDLE";
        }

        @Override
        public String getId() { return id; }

        @Override
        public void setId(String id) { this.id = id; }

        @Override
        public LocalDateTime getCreatedAt() { return createdAt; }

        @Override
        public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }

        @Override
        public String getCurrentState() { return currentState; }

        @Override
        public void setCurrentState(String state) { this.currentState = state; }

        @Override
        public LocalDateTime getLastStateChange() { return lastStateChange; }

        @Override
        public void setLastStateChange(LocalDateTime timestamp) { this.lastStateChange = timestamp; }

        @Override
        public boolean isComplete() { return isComplete; }

        @Override
        public void setComplete(boolean complete) { this.isComplete = complete; }

        @Override
        public void markComplete() { this.isComplete = true; }

        @Override
        public CallContext deepCopy() {
            CallContext copy = new CallContext();
            copy.id = this.id;
            copy.createdAt = this.createdAt;
            copy.currentState = this.currentState;
            copy.lastStateChange = this.lastStateChange;
            copy.callerNumber = this.callerNumber;
            copy.calleeNumber = this.calleeNumber;
            copy.isComplete = this.isComplete;
            return copy;
        }

        public String getCallerNumber() { return callerNumber; }
        public void setCallerNumber(String callerNumber) { this.callerNumber = callerNumber; }
        public String getCalleeNumber() { return calleeNumber; }
        public void setCalleeNumber(String calleeNumber) { this.calleeNumber = calleeNumber; }
    }

    // Simple events
    public static class DialEvent extends com.telcobright.statemachine.StateMachineEvent {}
    public static class RingEvent extends com.telcobright.statemachine.StateMachineEvent {}
    public static class AnswerEvent extends com.telcobright.statemachine.StateMachineEvent {}
    public static class HangupEvent extends com.telcobright.statemachine.StateMachineEvent {}

    public static void main(String[] args) {
        System.out.println("\n" + "=".repeat(80));
        System.out.println("   HISTORY ARCHIVAL INTEGRATION TEST");
        System.out.println("=".repeat(80));
        System.out.println();

        try {
            // Cleanup before testing
            cleanupDatabases();

            // Create registry and state machines
            log.info("Setting up registry and state machines...");

            TimeoutManager timeoutManager = new TimeoutManager("test-timeout", 2);
            StateMachineRegistry registry = new StateMachineRegistry(REGISTRY_ID, timeoutManager);

            // Configure history archival
            registry.enableHistory(30);  // 30-day retention

            log.info("History archival enabled with 30-day retention");

            // Create shard config
            ShardConfig shardConfig = ShardConfig.builder()
                .shardId("shard-1")
                .host(DB_HOST)
                .port(DB_PORT)
                .database(ACTIVE_DB)
                .username(DB_USER)
                .password(DB_PASSWORD)
                .connectionPoolSize(5)
                .enabled(true)
                .build();

            // Initialize history managers
            EntityGraphMapper graphMapper = new EntityGraphMapper();
            registry.initializeHistoryManagers(shardConfig, RepositoryMode.MULTI_TABLE, graphMapper);

            log.info("History managers initialized");

            // Test 1: Create machines and test automatic archival
            testAutomaticArchival(registry, timeoutManager);

            // Test 2: Test startup scan
            testStartupScan(registry, shardConfig, graphMapper);

            // Test 3: Verify data in history database
            testHistoryDataVerification();

            // Test 4: Check archival statistics
            testArchivalStatistics(registry);

            // Cleanup
            registry.shutdown();
            timeoutManager.shutdown();

            System.out.println("\n" + "=".repeat(80));
            System.out.println("   ✅ ALL HISTORY ARCHIVAL INTEGRATION TESTS PASSED");
            System.out.println("=".repeat(80));

        } catch (Exception e) {
            log.error("Test failed", e);
            System.err.println("\n❌ TEST FAILED: " + e.getMessage());
            e.printStackTrace();
            System.exit(1);
        }
    }

    /**
     * Test 1: Automatic archival when machines reach final states
     */
    private static void testAutomaticArchival(StateMachineRegistry registry, TimeoutManager timeoutManager)
            throws Exception {
        System.out.println("\nTEST 1: Automatic Archival on Final State");
        System.out.println("-".repeat(60));

        // Create state machine builder with final states
        EnhancedFluentBuilder<CallContext, Object> builder =
            new EnhancedFluentBuilder<>(timeoutManager, registry);

        builder.state("IDLE")
                .onEntry((machine, event) -> {
                    log.info("Machine {} entered IDLE state", machine.getId());
                })
            .and()
            .state("DIALING")
                .onEntry((machine, event) -> {
                    log.info("Machine {} dialing...", machine.getId());
                })
            .and()
            .state("RINGING")
                .onEntry((machine, event) -> {
                    log.info("Machine {} ringing...", machine.getId());
                })
            .and()
            .state("CONNECTED")
                .onEntry((machine, event) -> {
                    log.info("Machine {} connected", machine.getId());
                })
            .and()
            .state("COMPLETED")
                .finalState()  // Mark as final state
                .onEntry((machine, event) -> {
                    log.info("Machine {} completed - final state reached", machine.getId());
                })
            .and()
            .transition().from("IDLE").to("DIALING").on(DialEvent.class)
            .and()
            .transition().from("DIALING").to("RINGING").on(RingEvent.class)
            .and()
            .transition().from("RINGING").to("CONNECTED").on(AnswerEvent.class)
            .and()
            .transition().from("CONNECTED").to("COMPLETED").on(HangupEvent.class)
            .and()
            .initialState("IDLE");

        // Create test machines
        int machineCount = 5;
        log.info("Creating {} test machines", machineCount);

        for (int i = 1; i <= machineCount; i++) {
            String machineId = String.format("call-%03d", i);
            CallContext context = new CallContext(machineId, "+1234567890", "+0987654321");

            GenericStateMachine<CallContext, Object> machine = builder.build(machineId);
            machine.setPersistingEntity(context);

            registry.register(machineId, machine);

            log.info("Created machine: {}", machineId);
        }

        // Run machines through their lifecycle
        log.info("Running machines through lifecycle...");

        for (int i = 1; i <= machineCount; i++) {
            String machineId = String.format("call-%03d", i);

            // Process events to reach final state
            registry.routeEvent(machineId, new DialEvent());
            Thread.sleep(100);

            registry.routeEvent(machineId, new RingEvent());
            Thread.sleep(100);

            registry.routeEvent(machineId, new AnswerEvent());
            Thread.sleep(100);

            registry.routeEvent(machineId, new HangupEvent());
            log.info("Machine {} reached COMPLETED state", machineId);
            Thread.sleep(100);
        }

        // Wait for async archival to complete
        log.info("Waiting for async archival to complete...");
        Thread.sleep(5000);

        // Verify machines are evicted from active registry
        for (int i = 1; i <= machineCount; i++) {
            String machineId = String.format("call-%03d", i);
            boolean inMemory = registry.isInMemory(machineId);
            log.info("Machine {} in memory: {}", machineId, inMemory);

            if (inMemory) {
                log.warn("WARNING: Machine {} still in memory (should be evicted)", machineId);
            }
        }

        System.out.println("✅ Test 1 passed - Machines processed through lifecycle\n");
    }

    /**
     * Test 2: Startup scan functionality
     */
    private static void testStartupScan(StateMachineRegistry registry, ShardConfig shardConfig,
                                       EntityGraphMapper graphMapper) throws Exception {
        System.out.println("TEST 2: Startup Scan for Finished Machines");
        System.out.println("-".repeat(60));

        // Insert test machines directly into database (simulating existing data)
        createDirectDatabaseMachines();

        // Create new registry and perform startup scan
        log.info("Creating new registry for startup scan test...");
        TimeoutManager scanTimeoutManager = new TimeoutManager("scan-timeout", 2);
        StateMachineRegistry scanRegistry = new StateMachineRegistry(REGISTRY_ID + "-scan", scanTimeoutManager);

        scanRegistry.enableHistory(30);
        scanRegistry.initializeHistoryManagers(shardConfig, RepositoryMode.MULTI_TABLE, graphMapper);

        try {
            log.info("Performing startup scan...");
            scanRegistry.performStartupHistoryScan();
            log.info("Startup scan completed successfully");
        } catch (SQLException e) {
            log.error("Startup scan failed", e);
            throw e;
        } finally {
            scanRegistry.shutdown();
            scanTimeoutManager.shutdown();
        }

        System.out.println("✅ Test 2 passed - Startup scan completed\n");
    }

    /**
     * Test 3: Verify data in history database
     */
    private static void testHistoryDataVerification() throws Exception {
        System.out.println("TEST 3: History Database Data Verification");
        System.out.println("-".repeat(60));

        String jdbcUrl = String.format("jdbc:mysql://%s:%d/?useSSL=false&serverTimezone=UTC",
            DB_HOST, DB_PORT);

        try (Connection conn = DriverManager.getConnection(jdbcUrl, DB_USER, DB_PASSWORD)) {
            // Check if history database exists
            ResultSet rs = conn.getMetaData().getCatalogs();
            boolean historyDbExists = false;

            while (rs.next()) {
                String dbName = rs.getString("TABLE_CAT");
                if (dbName.equals(HISTORY_DB)) {
                    historyDbExists = true;
                    break;
                }
            }

            log.info("History database exists: {}", historyDbExists);

            if (historyDbExists) {
                // Count records in history database
                try (Statement stmt = conn.createStatement()) {
                    stmt.execute("USE `" + HISTORY_DB + "`");

                    // Check tables
                    ResultSet tables = conn.getMetaData().getTables(HISTORY_DB, null, "%",
                        new String[]{"TABLE"});

                    int tableCount = 0;
                    while (tables.next()) {
                        String tableName = tables.getString("TABLE_NAME");
                        tableCount++;

                        // Count records in each table
                        ResultSet countRs = stmt.executeQuery(
                            "SELECT COUNT(*) FROM `" + tableName + "`");
                        if (countRs.next()) {
                            int recordCount = countRs.getInt(1);
                            log.info("Table {} has {} records", tableName, recordCount);
                        }
                    }

                    log.info("History database has {} tables", tableCount);
                }
            }
        }

        System.out.println("✅ Test 3 passed - History data verified\n");
    }

    /**
     * Test 4: Check archival statistics
     */
    private static void testArchivalStatistics(StateMachineRegistry registry) {
        System.out.println("TEST 4: Archival Statistics");
        System.out.println("-".repeat(60));

        HistoryArchivalManager.ArchivalStats stats = registry.getHistoryStats();

        if (stats != null) {
            log.info("Archival Statistics:");
            log.info("  Successful: {}", stats.successful);
            log.info("  Failed: {}", stats.failed);
            log.info("  Queued: {}", stats.queueSize);

            System.out.println("Archival stats: " + stats);
        } else {
            log.warn("No archival statistics available");
        }

        System.out.println("✅ Test 4 passed - Statistics retrieved\n");
    }

    /**
     * Create machines directly in database for startup scan test
     */
    private static void createDirectDatabaseMachines() throws SQLException {
        String jdbcUrl = String.format("jdbc:mysql://%s:%d/?useSSL=false&serverTimezone=UTC",
            DB_HOST, DB_PORT);

        try (Connection conn = DriverManager.getConnection(jdbcUrl, DB_USER, DB_PASSWORD);
             Statement stmt = conn.createStatement()) {

            // Create database and table
            stmt.execute("CREATE DATABASE IF NOT EXISTS `" + ACTIVE_DB + "`");
            stmt.execute("USE `" + ACTIVE_DB + "`");
            stmt.execute(
                "CREATE TABLE IF NOT EXISTS `call_contexts` (" +
                "  id VARCHAR(100) PRIMARY KEY," +
                "  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP," +
                "  current_state VARCHAR(50)," +
                "  last_state_change TIMESTAMP DEFAULT CURRENT_TIMESTAMP," +
                "  caller_number VARCHAR(20)," +
                "  callee_number VARCHAR(20)," +
                "  is_complete BOOLEAN DEFAULT FALSE" +
                ")"
            );

            // Insert machines in final states
            try (PreparedStatement ps = conn.prepareStatement(
                    "INSERT INTO `call_contexts` (id, current_state, is_complete) VALUES (?, ?, ?)")) {

                for (int i = 1; i <= 3; i++) {
                    String machineId = String.format("startup-%03d", i);
                    ps.setString(1, machineId);
                    ps.setString(2, "COMPLETED");
                    ps.setBoolean(3, true);
                    ps.executeUpdate();
                }

                log.info("Created 3 machines in final state for startup scan test");
            }
        }
    }

    /**
     * Cleanup test databases
     */
    private static void cleanupDatabases() throws SQLException {
        String jdbcUrl = String.format("jdbc:mysql://%s:%d/?useSSL=false&serverTimezone=UTC",
            DB_HOST, DB_PORT);

        try (Connection conn = DriverManager.getConnection(jdbcUrl, DB_USER, DB_PASSWORD);
             Statement stmt = conn.createStatement()) {

            // Drop all test databases
            stmt.execute("DROP DATABASE IF EXISTS `" + ACTIVE_DB + "`");
            stmt.execute("DROP DATABASE IF EXISTS `" + HISTORY_DB + "`");
            stmt.execute("DROP DATABASE IF EXISTS `" + ACTIVE_DB + "-scan`");
            stmt.execute("DROP DATABASE IF EXISTS `" + ACTIVE_DB + "-scan-history`");

            log.info("Cleaned up test databases");
        }
    }
}
