package com.telcobright.statemachine.test;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

/**
 * Master Test Runner for TelcoBright State Machine Library
 * Orchestrates comprehensive testing of both Call and SMS state machines
 */
public class MasterTestRunner {
    
    private static final String BANNER = """
        ╔═══════════════════════════════════════════════════════════════╗
        ║           🎯 TELCOBRIGHT STATE MACHINE TEST SUITE              ║
        ║                   Comprehensive Testing                       ║
        ╚═══════════════════════════════════════════════════════════════╝
        """;
    
    private TestDatabaseManager dbManager;
    private String masterTestRunId;
    
    public MasterTestRunner() throws Exception {
        this.masterTestRunId = "MASTER_TEST_" + LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss"));
        this.dbManager = new TestDatabaseManager();
    }
    
    /**
     * Run all tests in sequence
     */
    public void runAllTestsSequentially() {
        System.out.println(BANNER);
        System.out.println("🚀 Starting Master Test Suite");
        System.out.println("Test Run ID: " + masterTestRunId);
        System.out.println("Execution Mode: SEQUENTIAL");
        System.out.println("Started at: " + LocalDateTime.now());
        System.out.println("═".repeat(80));
        
        long startTime = System.currentTimeMillis();
        boolean allTestsPassed = true;
        
        try {
            // Test 1: Call Machine Tests
            System.out.println("\n📞 === PHASE 1: CALL MACHINE TESTING ===");
            ComprehensiveCallMachineTest callTests = new ComprehensiveCallMachineTest();
            callTests.runAllTests();
            
            Thread.sleep(2000); // Brief pause between test suites
            
            // Test 2: SMS Machine Tests
            System.out.println("\n📱 === PHASE 2: SMS MACHINE TESTING ===");
            ComprehensiveSmsMachineTest smsTests = new ComprehensiveSmsMachineTest();
            smsTests.runAllTests();
            
            Thread.sleep(1000);
            
            // Final comprehensive analysis
            System.out.println("\n🔍 === COMPREHENSIVE ANALYSIS ===");
            performComprehensiveAnalysis();
            
        } catch (Exception e) {
            allTestsPassed = false;
            System.err.println("❌ Master test suite failed: " + e.getMessage());
            e.printStackTrace();
        } finally {
            long endTime = System.currentTimeMillis();
            double durationMinutes = (endTime - startTime) / 1000.0 / 60.0;
            
            System.out.println("\n" + "═".repeat(80));
            System.out.println("🏁 === MASTER TEST SUITE COMPLETED ===");
            System.out.println("Total execution time: " + String.format("%.2f", durationMinutes) + " minutes");
            System.out.println("Status: " + (allTestsPassed ? "✅ SUCCESS" : "❌ FAILED"));
            System.out.println("Completed at: " + LocalDateTime.now());
            
            try {
                dbManager.close();
            } catch (Exception e) {
                System.err.println("Failed to close master database connection: " + e.getMessage());
            }
        }
    }
    
    /**
     * Run all tests in parallel for faster execution
     */
    public void runAllTestsInParallel() {
        System.out.println(BANNER);
        System.out.println("🚀 Starting Master Test Suite");
        System.out.println("Test Run ID: " + masterTestRunId);
        System.out.println("Execution Mode: PARALLEL");
        System.out.println("Started at: " + LocalDateTime.now());
        System.out.println("═".repeat(80));
        
        ExecutorService executor = Executors.newFixedThreadPool(2);
        long startTime = System.currentTimeMillis();
        boolean allTestsPassed = true;
        
        try {
            // Submit both test suites to run in parallel
            Future<Boolean> callTestFuture = executor.submit(() -> {
                try {
                    System.out.println("\n📞 === PARALLEL: CALL MACHINE TESTING ===");
                    ComprehensiveCallMachineTest callTests = new ComprehensiveCallMachineTest();
                    callTests.runAllTests();
                    return true;
                } catch (Exception e) {
                    System.err.println("❌ Call machine tests failed: " + e.getMessage());
                    return false;
                }
            });
            
            Future<Boolean> smsTestFuture = executor.submit(() -> {
                try {
                    System.out.println("\n📱 === PARALLEL: SMS MACHINE TESTING ===");
                    ComprehensiveSmsMachineTest smsTests = new ComprehensiveSmsMachineTest();
                    smsTests.runAllTests();
                    return true;
                } catch (Exception e) {
                    System.err.println("❌ SMS machine tests failed: " + e.getMessage());
                    return false;
                }
            });
            
            // Wait for both test suites to complete
            boolean callTestsSuccess = callTestFuture.get(30, TimeUnit.MINUTES);
            boolean smsTestsSuccess = smsTestFuture.get(30, TimeUnit.MINUTES);
            
            allTestsPassed = callTestsSuccess && smsTestsSuccess;
            
            if (allTestsPassed) {
                System.out.println("\n🔍 === COMPREHENSIVE ANALYSIS ===");
                performComprehensiveAnalysis();
            }
            
        } catch (Exception e) {
            allTestsPassed = false;
            System.err.println("❌ Parallel test execution failed: " + e.getMessage());
            e.printStackTrace();
        } finally {
            executor.shutdown();
            try {
                if (!executor.awaitTermination(5, TimeUnit.MINUTES)) {
                    executor.shutdownNow();
                }
            } catch (InterruptedException e) {
                executor.shutdownNow();
            }
            
            long endTime = System.currentTimeMillis();
            double durationMinutes = (endTime - startTime) / 1000.0 / 60.0;
            
            System.out.println("\n" + "═".repeat(80));
            System.out.println("🏁 === MASTER TEST SUITE COMPLETED ===");
            System.out.println("Total execution time: " + String.format("%.2f", durationMinutes) + " minutes");
            System.out.println("Status: " + (allTestsPassed ? "✅ SUCCESS" : "❌ FAILED"));
            System.out.println("Completed at: " + LocalDateTime.now());
            
            try {
                dbManager.close();
            } catch (Exception e) {
                System.err.println("Failed to close master database connection: " + e.getMessage());
            }
        }
    }
    
    /**
     * Perform comprehensive analysis of all test results
     */
    private void performComprehensiveAnalysis() {
        try {
            System.out.println("📊 Analyzing comprehensive test results...");
            
            // Get today's test runs
            String datePattern = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd"));
            
            String analysisQuery = """
                SELECT 
                    test_type,
                    COUNT(*) as total_tests,
                    SUM(CASE WHEN status = 'PASSED' THEN 1 ELSE 0 END) as passed_tests,
                    SUM(CASE WHEN status = 'FAILED' THEN 1 ELSE 0 END) as failed_tests,
                    SUM(assertions_count) as total_assertions,
                    SUM(assertions_passed) as passed_assertions,
                    AVG(TIMESTAMPDIFF(MICROSECOND, start_time, end_time) / 1000) as avg_execution_ms
                FROM test_execution_log 
                WHERE test_run_id LIKE ?
                GROUP BY test_type
                ORDER BY test_type
                """;
            
            System.out.println("\n📈 === COMPREHENSIVE TEST ANALYSIS ===");
            try (var rs = dbManager.executeQuery(analysisQuery, datePattern + "%")) {
                int totalTests = 0, totalPassed = 0, totalAssertions = 0, totalPassedAssertions = 0;
                
                while (rs.next()) {
                    String testType = rs.getString("test_type");
                    int tests = rs.getInt("total_tests");
                    int passed = rs.getInt("passed_tests");
                    int failed = rs.getInt("failed_tests");
                    int assertions = rs.getInt("total_assertions");
                    int passedAsserts = rs.getInt("passed_assertions");
                    double avgMs = rs.getDouble("avg_execution_ms");
                    
                    double passRate = tests > 0 ? (passed * 100.0 / tests) : 0;
                    double assertRate = assertions > 0 ? (passedAsserts * 100.0 / assertions) : 0;
                    
                    System.out.printf("🔸 %-20s: %3d tests (%3d✅ %3d❌) | %.1f%% pass | %4d assertions (%.1f%%) | %.2fms avg%n",
                        testType, tests, passed, failed, passRate, assertions, assertRate, avgMs);
                    
                    totalTests += tests;
                    totalPassed += passed;
                    totalAssertions += assertions;
                    totalPassedAssertions += passedAsserts;
                }
                
                double overallPassRate = totalTests > 0 ? (totalPassed * 100.0 / totalTests) : 0;
                double overallAssertRate = totalAssertions > 0 ? (totalPassedAssertions * 100.0 / totalAssertions) : 0;
                
                System.out.println("─".repeat(90));
                System.out.printf("🎯 OVERALL SUMMARY: %d tests (%.1f%% pass) | %d assertions (%.1f%% pass)%n",
                    totalTests, overallPassRate, totalAssertions, overallAssertRate);
            }
            
            // Analyze state machine integrity across all tests
            System.out.println("\n🔍 === STATE MACHINE INTEGRITY ANALYSIS ===");
            
            String integrityQuery = """
                SELECT 
                    'CALL' as machine_type,
                    COUNT(DISTINCT call_id) as unique_machines,
                    COUNT(*) as total_transitions,
                    COUNT(DISTINCT state_name) as unique_states
                FROM call_state_snapshots 
                WHERE test_run_id LIKE ?
                UNION ALL
                SELECT 
                    'SMS' as machine_type,
                    COUNT(DISTINCT sms_id) as unique_machines,
                    COUNT(*) as total_transitions,
                    COUNT(DISTINCT state_name) as unique_states
                FROM sms_state_snapshots 
                WHERE test_run_id LIKE ?
                """;
            
            try (var rs = dbManager.executeQuery(integrityQuery, datePattern + "%", datePattern + "%")) {
                while (rs.next()) {
                    String machineType = rs.getString("machine_type");
                    int uniqueMachines = rs.getInt("unique_machines");
                    int totalTransitions = rs.getInt("total_transitions");
                    int uniqueStates = rs.getInt("unique_states");
                    
                    System.out.printf("🔸 %-4s machines: %3d instances | %4d transitions | %2d states%n",
                        machineType, uniqueMachines, totalTransitions, uniqueStates);
                }
            }
            
            // Performance analysis
            System.out.println("\n⚡ === PERFORMANCE ANALYSIS ===");
            
            String performanceQuery = """
                SELECT 
                    test_type,
                    MIN(TIMESTAMPDIFF(MICROSECOND, start_time, end_time) / 1000) as min_ms,
                    MAX(TIMESTAMPDIFF(MICROSECOND, start_time, end_time) / 1000) as max_ms,
                    AVG(TIMESTAMPDIFF(MICROSECOND, start_time, end_time) / 1000) as avg_ms,
                    STDDEV(TIMESTAMPDIFF(MICROSECOND, start_time, end_time) / 1000) as stddev_ms
                FROM test_execution_log 
                WHERE test_run_id LIKE ? AND end_time IS NOT NULL
                GROUP BY test_type
                ORDER BY avg_ms DESC
                """;
            
            try (var rs = dbManager.executeQuery(performanceQuery, datePattern + "%")) {
                while (rs.next()) {
                    String testType = rs.getString("test_type");
                    double minMs = rs.getDouble("min_ms");
                    double maxMs = rs.getDouble("max_ms");
                    double avgMs = rs.getDouble("avg_ms");
                    double stddevMs = rs.getDouble("stddev_ms");
                    
                    System.out.printf("🔸 %-20s: %.2fms avg (%.2f-%.2fms range, ±%.2fms σ)%n",
                        testType, avgMs, minMs, maxMs, stddevMs);
                }
            }
            
            System.out.println("✅ Comprehensive analysis completed");
            
        } catch (Exception e) {
            System.err.println("❌ Failed to perform comprehensive analysis: " + e.getMessage());
            e.printStackTrace();
        }
    }
    
    /**
     * Run specific test type only
     */
    public void runSpecificTests(String testType) {
        System.out.println(BANNER);
        System.out.println("🎯 Running specific test type: " + testType);
        
        try {
            switch (testType.toUpperCase()) {
                case "CALL":
                    ComprehensiveCallMachineTest callTests = new ComprehensiveCallMachineTest();
                    callTests.runAllTests();
                    break;
                case "SMS":
                    ComprehensiveSmsMachineTest smsTests = new ComprehensiveSmsMachineTest();
                    smsTests.runAllTests();
                    break;
                default:
                    System.err.println("❌ Unknown test type: " + testType);
                    System.err.println("Available types: CALL, SMS");
                    break;
            }
        } catch (Exception e) {
            System.err.println("❌ Failed to run " + testType + " tests: " + e.getMessage());
            e.printStackTrace();
        }
    }
    
    /**
     * Main method with command line options
     */
    public static void main(String[] args) {
        try {
            MasterTestRunner runner = new MasterTestRunner();
            
            if (args.length == 0) {
                // Default: run all tests sequentially
                runner.runAllTestsSequentially();
            } else {
                String command = args[0].toLowerCase();
                switch (command) {
                    case "sequential":
                    case "seq":
                        runner.runAllTestsSequentially();
                        break;
                    case "parallel":
                    case "par":
                        runner.runAllTestsInParallel();
                        break;
                    case "call":
                        runner.runSpecificTests("CALL");
                        break;
                    case "sms":
                        runner.runSpecificTests("SMS");
                        break;
                    case "help":
                        printUsage();
                        break;
                    default:
                        System.err.println("❌ Unknown command: " + command);
                        printUsage();
                        System.exit(1);
                }
            }
        } catch (Exception e) {
            System.err.println("❌ Failed to run master test suite: " + e.getMessage());
            e.printStackTrace();
            System.exit(1);
        }
    }
    
    /**
     * Print usage information
     */
    private static void printUsage() {
        System.out.println("""
            
            🎯 TelcoBright State Machine Test Suite
            
            Usage: java MasterTestRunner [command]
            
            Commands:
              sequential, seq     Run all tests sequentially (default)
              parallel, par       Run all tests in parallel (faster)
              call               Run only Call machine tests
              sms                Run only SMS machine tests  
              help               Show this help message
            
            Examples:
              java MasterTestRunner                    # Run all tests sequentially
              java MasterTestRunner parallel           # Run all tests in parallel
              java MasterTestRunner call               # Run only call tests
              java MasterTestRunner sms                # Run only SMS tests
            
            Requirements:
              - MySQL server running on 127.0.0.1:3306
              - Database credentials: root/123456
              - Java 17+
              - Maven dependencies resolved
            """);
    }
}