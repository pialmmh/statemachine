package com.telcobright.statemachine.test;

import com.telcobright.core.repository.SplitVerseRepository;
import com.telcobright.splitverse.config.ShardConfig;
import com.telcobright.splitverse.config.RepositoryMode;
import com.telcobright.core.repository.GenericMultiTableRepository;
import com.telcobright.core.partition.PartitionType;
import com.telcobright.core.entity.ShardingEntity;
import com.telcobright.core.annotation.*;

import java.sql.*;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.ArrayList;
import java.util.UUID;

/**
 * Comprehensive test for both Split-Verse repository modes:
 * 1. PARTITIONED mode - Single table with MySQL native partitions
 * 2. MULTI_TABLE mode - Separate table for each day
 */
public class SplitVerseModesTest {

    @Table(name = "calls")
    public static class CallEntity implements ShardingEntity {

        @Id(autoGenerated = false)
        @Column(name = "call_id")
        private String id;

        @com.telcobright.core.annotation.ShardingKey
        @Column(name = "created_at")
        private LocalDateTime createdAt;

        @Column(name = "caller")
        private String caller;

        @Column(name = "callee")
        private String callee;

        @Column(name = "duration")
        private Integer duration;

        @Column(name = "status")
        private String status;

        public CallEntity() {
            this.status = "INITIATED";
            this.duration = 0;
        }

        @Override
        public String getId() { return id; }

        @Override
        public void setId(String id) { this.id = id; }

        @Override
        public LocalDateTime getCreatedAt() { return createdAt; }

        @Override
        public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }

        public String getCaller() { return caller; }
        public void setCaller(String caller) { this.caller = caller; }

        public String getCallee() { return callee; }
        public void setCallee(String callee) { this.callee = callee; }

        public Integer getDuration() { return duration; }
        public void setDuration(Integer duration) { this.duration = duration; }

        public String getStatus() { return status; }
        public void setStatus(String status) { this.status = status; }
    }

    public static void main(String[] args) {
        System.out.println("\n" + "=".repeat(80));
        System.out.println("   SPLIT-VERSE REPOSITORY MODES TEST");
        System.out.println("   Testing both PARTITIONED and MULTI_TABLE modes");
        System.out.println("=".repeat(80));
        System.out.println();

        ShardConfig config = ShardConfig.builder()
            .shardId("primary")
            .host("127.0.0.1")
            .port(3306)
            .database("statemachine_test")
            .username("root")
            .password("123456")
            .connectionPoolSize(10)
            .enabled(true)
            .build();

        try {
            // Test 1: PARTITIONED Mode (Default)
            System.out.println("‚îÅ".repeat(80));
            System.out.println("TEST 1: PARTITIONED MODE (Single table with MySQL partitions)");
            System.out.println("‚îÅ".repeat(80));
            testPartitionedMode(config);

            Thread.sleep(2000); // Brief pause between tests

            // Test 2: MULTI_TABLE Mode
            System.out.println("\n" + "‚îÅ".repeat(80));
            System.out.println("TEST 2: MULTI_TABLE MODE (Separate table for each day)");
            System.out.println("‚îÅ".repeat(80));
            testMultiTableMode(config);

            // Final database report
            System.out.println("\n" + "‚îÅ".repeat(80));
            System.out.println("FINAL DATABASE STRUCTURE REPORT");
            System.out.println("‚îÅ".repeat(80));
            reportCompleteDbStructure(config);

        } catch (Exception e) {
            System.err.println("‚ùå Test failed: " + e.getMessage());
            e.printStackTrace();
        }

        System.out.println("\n" + "=".repeat(80));
        System.out.println("   TEST COMPLETED");
        System.out.println("=".repeat(80));
    }

    private static void testPartitionedMode(ShardConfig config) throws Exception {
        System.out.println("\nüìã Creating PARTITIONED mode repository...");

        // Drop existing table if it exists
        dropTable(config, "calls");

        SplitVerseRepository<CallEntity> repository =
            SplitVerseRepository.<CallEntity>builder()
                .withSingleShard(config)
                .withEntityClass(CallEntity.class)
                .withRepositoryMode(RepositoryMode.PARTITIONED)  // Explicitly set, though it's default
                .withPartitionType(PartitionType.DATE_BASED)
                .withPartitionKeyColumn("created_at")
                .withRetentionDays(7)  // Creates 15 partitions (7 past + today + 7 future)
                .build();

        System.out.println("‚úÖ Repository created in PARTITIONED mode");
        System.out.println("   Expected: Single table 'calls' with date-based partitions");

        // Insert test data across multiple days
        System.out.println("\nüìù Inserting test data across multiple days...");
        List<String> ids = insertTestData(repository, "PART");

        // Verify data retrieval
        System.out.println("\nüîç Verifying data retrieval...");
        verifyDataRetrieval(repository, ids);

        // Show table structure
        System.out.println("\nüìä Table structure in PARTITIONED mode:");
        showTableInfo(config, "calls");

        repository.shutdown();
        System.out.println("\n‚úÖ PARTITIONED mode test completed");
    }

    private static void testMultiTableMode(ShardConfig config) throws Exception {
        System.out.println("\nüìã Creating MULTI_TABLE mode repository...");

        // Drop existing tables with pattern
        dropTablesWithPattern(config, "calls_%");

        SplitVerseRepository<CallEntity> repository =
            SplitVerseRepository.<CallEntity>builder()
                .withSingleShard(config)
                .withEntityClass(CallEntity.class)
                .withRepositoryMode(RepositoryMode.MULTI_TABLE)  // Explicitly set multi-table mode
                .withTableGranularity(GenericMultiTableRepository.TableGranularity.DAILY)
                .withRetentionDays(7)  // Keep 7 days of tables
                .build();

        System.out.println("‚úÖ Repository created in MULTI_TABLE mode");
        System.out.println("   Expected: Separate tables like 'calls_2025_09_14' for each day");

        // Insert test data across multiple days
        System.out.println("\nüìù Inserting test data across multiple days...");
        List<String> ids = insertTestData(repository, "MULTI");

        // Verify data retrieval
        System.out.println("\nüîç Verifying data retrieval...");
        verifyDataRetrieval(repository, ids);

        // Show all created tables
        System.out.println("\nüìä Tables created in MULTI_TABLE mode:");
        showMultiTableInfo(config);

        repository.shutdown();
        System.out.println("\n‚úÖ MULTI_TABLE mode test completed");
    }

    private static List<String> insertTestData(SplitVerseRepository<CallEntity> repository, String prefix) throws SQLException {
        List<String> ids = new ArrayList<>();
        LocalDateTime now = LocalDateTime.now();
        int totalInserted = 0;

        // Insert data for today
        for (int i = 0; i < 10; i++) {
            CallEntity call = createCall(prefix, i, now);
            repository.insert(call);
            ids.add(call.getId());
            totalInserted++;
            if (i < 2) {
                System.out.println("   Day 0 (today): " + call.getId() + " at " +
                    call.getCreatedAt().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm")));
            }
        }

        // Insert data for yesterday
        for (int i = 0; i < 8; i++) {
            CallEntity call = createCall(prefix, 100 + i, now.minusDays(1));
            repository.insert(call);
            ids.add(call.getId());
            totalInserted++;
            if (i < 2) {
                System.out.println("   Day -1 (yesterday): " + call.getId() + " at " +
                    call.getCreatedAt().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm")));
            }
        }

        // Insert data for 2 days ago
        for (int i = 0; i < 6; i++) {
            CallEntity call = createCall(prefix, 200 + i, now.minusDays(2));
            repository.insert(call);
            ids.add(call.getId());
            totalInserted++;
            if (i < 2) {
                System.out.println("   Day -2 (2 days ago): " + call.getId() + " at " +
                    call.getCreatedAt().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm")));
            }
        }

        System.out.println("   ‚úÖ Total inserted: " + totalInserted + " call records across 3 days");
        return ids;
    }

    private static CallEntity createCall(String prefix, int index, LocalDateTime dateTime) {
        CallEntity call = new CallEntity();
        call.setId(prefix + "-" + UUID.randomUUID().toString().substring(0, 8));
        call.setCreatedAt(dateTime);
        call.setCaller("+1-555-" + String.format("%04d", 1000 + index));
        call.setCallee("+1-555-" + String.format("%04d", 2000 + index));
        call.setDuration(60 + (index * 10));
        call.setStatus(index % 3 == 0 ? "COMPLETED" : "INITIATED");
        return call;
    }

    private static void verifyDataRetrieval(SplitVerseRepository<CallEntity> repository, List<String> ids) throws SQLException {
        // Test individual retrieval
        int found = 0;
        for (int i = 0; i < Math.min(5, ids.size()); i++) {
            CallEntity call = repository.findById(ids.get(i));
            if (call != null) {
                found++;
                if (i < 2) {
                    System.out.println("   Found: " + call.getId() + " (Status: " + call.getStatus() +
                        ", Duration: " + call.getDuration() + "s)");
                }
            }
        }
        System.out.println("   ‚úÖ Retrieved " + found + "/" + Math.min(5, ids.size()) + " records by ID");

        // Test date range query
        LocalDateTime start = LocalDateTime.now().minusDays(3);
        LocalDateTime end = LocalDateTime.now().plusDays(1);
        List<CallEntity> rangeResults = repository.findAllByDateRange(start, end);
        System.out.println("   ‚úÖ Date range query returned " + rangeResults.size() + " records");
    }

    private static void dropTable(ShardConfig config, String tableName) {
        String jdbcUrl = String.format("jdbc:mysql://%s:%d/%s?useSSL=false&serverTimezone=UTC",
            config.getHost(), config.getPort(), config.getDatabase());

        try (Connection conn = DriverManager.getConnection(jdbcUrl, config.getUsername(), config.getPassword())) {
            Statement stmt = conn.createStatement();
            stmt.execute("DROP TABLE IF EXISTS " + tableName);
            System.out.println("   Dropped table if exists: " + tableName);
        } catch (SQLException e) {
            // Ignore errors
        }
    }

    private static void dropTablesWithPattern(ShardConfig config, String pattern) {
        String jdbcUrl = String.format("jdbc:mysql://%s:%d/%s?useSSL=false&serverTimezone=UTC",
            config.getHost(), config.getPort(), config.getDatabase());

        try (Connection conn = DriverManager.getConnection(jdbcUrl, config.getUsername(), config.getPassword())) {
            // Find all tables matching pattern
            DatabaseMetaData metaData = conn.getMetaData();
            ResultSet rs = metaData.getTables(config.getDatabase(), null, pattern, new String[]{"TABLE"});

            List<String> tablesToDrop = new ArrayList<>();
            while (rs.next()) {
                tablesToDrop.add(rs.getString("TABLE_NAME"));
            }
            rs.close();

            // Drop each table
            Statement stmt = conn.createStatement();
            for (String table : tablesToDrop) {
                stmt.execute("DROP TABLE IF EXISTS " + table);
                System.out.println("   Dropped table: " + table);
            }
        } catch (SQLException e) {
            // Ignore errors
        }
    }

    private static void showTableInfo(ShardConfig config, String tableName) {
        String jdbcUrl = String.format("jdbc:mysql://%s:%d/%s?useSSL=false&serverTimezone=UTC",
            config.getHost(), config.getPort(), config.getDatabase());

        try (Connection conn = DriverManager.getConnection(jdbcUrl, config.getUsername(), config.getPassword())) {
            // Show partition information
            String query = "SELECT PARTITION_NAME, PARTITION_EXPRESSION, PARTITION_DESCRIPTION " +
                          "FROM information_schema.PARTITIONS " +
                          "WHERE TABLE_SCHEMA = ? AND TABLE_NAME = ? " +
                          "AND PARTITION_NAME IS NOT NULL " +
                          "ORDER BY PARTITION_ORDINAL_POSITION";

            PreparedStatement pstmt = conn.prepareStatement(query);
            pstmt.setString(1, config.getDatabase());
            pstmt.setString(2, tableName);
            ResultSet rs = pstmt.executeQuery();

            System.out.println("\n   Partition Name | Expression | Description");
            System.out.println("   " + "-".repeat(60));
            int partitionCount = 0;
            while (rs.next()) {
                System.out.printf("   %-14s | %-10s | %s%n",
                    rs.getString("PARTITION_NAME"),
                    rs.getString("PARTITION_EXPRESSION"),
                    rs.getString("PARTITION_DESCRIPTION"));
                partitionCount++;
            }
            System.out.println("   Total partitions: " + partitionCount);

        } catch (SQLException e) {
            System.err.println("   Error getting table info: " + e.getMessage());
        }
    }

    private static void showMultiTableInfo(ShardConfig config) {
        String jdbcUrl = String.format("jdbc:mysql://%s:%d/%s?useSSL=false&serverTimezone=UTC",
            config.getHost(), config.getPort(), config.getDatabase());

        try (Connection conn = DriverManager.getConnection(jdbcUrl, config.getUsername(), config.getPassword())) {
            // Show all tables starting with 'calls_'
            String query = "SELECT TABLE_NAME, TABLE_ROWS, DATA_LENGTH, CREATE_TIME " +
                          "FROM information_schema.TABLES " +
                          "WHERE TABLE_SCHEMA = ? AND TABLE_NAME LIKE 'calls_%' " +
                          "ORDER BY TABLE_NAME";

            PreparedStatement pstmt = conn.prepareStatement(query);
            pstmt.setString(1, config.getDatabase());
            ResultSet rs = pstmt.executeQuery();

            System.out.println("\n   Table Name              | Rows | Size (KB) | Created");
            System.out.println("   " + "-".repeat(70));
            int tableCount = 0;
            long totalRows = 0;
            while (rs.next()) {
                String tableName = rs.getString("TABLE_NAME");
                long rows = rs.getLong("TABLE_ROWS");
                long dataLength = rs.getLong("DATA_LENGTH");
                Timestamp createTime = rs.getTimestamp("CREATE_TIME");

                System.out.printf("   %-23s | %4d | %9.2f | %s%n",
                    tableName,
                    rows,
                    dataLength / 1024.0,
                    createTime != null ? createTime.toString() : "N/A");

                tableCount++;
                totalRows += rows;
            }
            System.out.println("   " + "-".repeat(70));
            System.out.println("   Total: " + tableCount + " tables, " + totalRows + " rows");

        } catch (SQLException e) {
            System.err.println("   Error getting multi-table info: " + e.getMessage());
        }
    }

    private static void reportCompleteDbStructure(ShardConfig config) {
        String jdbcUrl = String.format("jdbc:mysql://%s:%d/%s?useSSL=false&serverTimezone=UTC",
            config.getHost(), config.getPort(), config.getDatabase());

        try (Connection conn = DriverManager.getConnection(jdbcUrl, config.getUsername(), config.getPassword())) {
            System.out.println("\nüìä Complete Database Structure:");

            // 1. Show all 'calls' related tables
            String tableQuery = "SELECT TABLE_NAME, TABLE_TYPE, ENGINE, TABLE_ROWS, DATA_LENGTH " +
                               "FROM information_schema.TABLES " +
                               "WHERE TABLE_SCHEMA = ? AND TABLE_NAME LIKE 'calls%' " +
                               "ORDER BY TABLE_NAME";

            PreparedStatement pstmt = conn.prepareStatement(tableQuery);
            pstmt.setString(1, config.getDatabase());
            ResultSet rs = pstmt.executeQuery();

            System.out.println("\n   All 'calls' tables in database:");
            System.out.println("   " + "=".repeat(80));
            System.out.println("   Table Name              | Type  | Engine | Rows | Size (KB)");
            System.out.println("   " + "-".repeat(80));

            List<String> tables = new ArrayList<>();
            while (rs.next()) {
                String tableName = rs.getString("TABLE_NAME");
                tables.add(tableName);
                System.out.printf("   %-23s | %-5s | %-6s | %4d | %9.2f%n",
                    tableName,
                    rs.getString("TABLE_TYPE"),
                    rs.getString("ENGINE"),
                    rs.getLong("TABLE_ROWS"),
                    rs.getLong("DATA_LENGTH") / 1024.0);
            }

            // 2. For each table, check if it has partitions
            for (String table : tables) {
                String partQuery = "SELECT COUNT(*) as partition_count " +
                                  "FROM information_schema.PARTITIONS " +
                                  "WHERE TABLE_SCHEMA = ? AND TABLE_NAME = ? " +
                                  "AND PARTITION_NAME IS NOT NULL";

                pstmt = conn.prepareStatement(partQuery);
                pstmt.setString(1, config.getDatabase());
                pstmt.setString(2, table);
                rs = pstmt.executeQuery();

                if (rs.next() && rs.getInt("partition_count") > 0) {
                    System.out.println("\n   üìÅ Table '" + table + "' has " +
                        rs.getInt("partition_count") + " partitions (PARTITIONED mode)");
                }
            }

            // 3. Summary
            System.out.println("\n   " + "=".repeat(80));
            System.out.println("   Summary:");
            if (tables.size() == 1 && tables.get(0).equals("calls")) {
                System.out.println("   ‚úÖ PARTITIONED mode: Single table with MySQL native partitions");
            } else if (tables.size() > 1) {
                System.out.println("   ‚úÖ MULTI_TABLE mode: " + tables.size() + " separate daily tables");
            }

        } catch (SQLException e) {
            System.err.println("   Error getting database structure: " + e.getMessage());
        }
    }
}