#!/usr/bin/env node

const fs = require('fs').promises;
const path = require('path');
const { program } = require('commander');
const handlebars = require('handlebars');

/**
 * State Machine Scaffolder - Generates Java state machine code from DSL
 */

// Register Handlebars helpers
handlebars.registerHelper('capitalize', (str) => str.charAt(0).toUpperCase() + str.slice(1));
handlebars.registerHelper('lowercase', (str) => str.toLowerCase());
handlebars.registerHelper('uppercase', (str) => str.toUpperCase());

// Template definitions
const templates = {
  // Main state machine class template
  stateMachine: `package {{packageBase}};

import com.telcobright.statemachine.FluentStateMachineBuilder;
import com.telcobright.statemachine.GenericStateMachine;
{{#each events}}
import {{../packageBase}}.events.{{this}};
{{/each}}
{{#each states}}
{{#each stayEvents}}
import {{@root.packageBase}}.states.{{lowercase ../name}}.On{{event}}_{{../name}};
{{/each}}
{{/each}}
import com.telcobright.statemachine.persistence.StateMachineSnapshotEntity;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.Properties;
import java.io.InputStream;
import java.io.IOException;

/**
 * {{machineName}} state machine definition
 * Generated by State Machine Scaffolder
 */
public class {{machineName}} {
    
    /**
     * Create and configure the {{lowercase machineName}} state machine
     */
    public GenericStateMachine createMachine(String machineId) {
        // Load profile-based configuration
        String activeProfile = loadActiveProfile();
        String configFile = "statemachine-" + activeProfile + ".properties";
        
        System.out.println("üîß Creating {{machineName}} with profile: " + activeProfile);
        
        // Create state machine with {{persistenceType}} persistence
        return FluentStateMachineBuilder.create(machineId)
            {{#if persistenceType}}
            .withDatabasePersistence(configFile)
            .withCustomSaveFunction({{machineName}}::save{{machineName}}Snapshot)
            .withCustomLoadFunction({{machineName}}::load{{machineName}}Snapshot)
            .withCustomInitFunction({{machineName}}::init{{machineName}}Table)
            {{/if}}
            .initialState({{stateName}}.{{uppercase initialState}})
            {{#each states}}
            .state({{../stateName}}.{{uppercase name}}){{#if offline}}.offline(){{/if}}
                {{#each transitions}}
                .on({{event}}.class).to({{@root.stateName}}.{{uppercase toState}})
                {{/each}}
                {{#each stayEvents}}
                .stay({{event}}.class, On{{event}}_{{../name}}::handle)
                {{/each}}
                .then()
            {{/each}}
            .buildAndStart();
    }
    
    
    /**
     * Load active profile from profile.properties
     */
    private static String loadActiveProfile() {
        Properties props = new Properties();
        try (InputStream input = {{machineName}}.class.getClassLoader().getResourceAsStream("profile.properties")) {
            if (input != null) {
                props.load(input);
                String profile = props.getProperty("active.profile", "dev");
                System.out.println("üîß Active profile: " + profile);
                return profile;
            }
        } catch (IOException e) {
            System.err.println("‚ö†Ô∏è Could not load profile.properties, using default: dev");
        }
        return "dev"; // default profile
    }
    
    {{#if persistenceType}}
    // ======================== CUSTOM SQL PERSISTENCE METHODS ========================
    
    /**
     * Custom save function for {{lowercase machineName}} snapshots
     */
    public static Boolean save{{machineName}}Snapshot(Connection conn, StateMachineSnapshotEntity snapshot) {
        String sql = "INSERT INTO {{lowercase machineName}}_snapshots (machine_id, state, context_data, timestamp, is_offline) VALUES (?, ?, ?, ?, ?)";
        
        try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
            pstmt.setString(1, snapshot.getMachineId());
            pstmt.setString(2, snapshot.getStateId());
            pstmt.setString(3, snapshot.getContext());
            pstmt.setTimestamp(4, Timestamp.valueOf(snapshot.getTimestamp()));
            pstmt.setBoolean(5, snapshot.getIsOffline());
            
            int rowsAffected = pstmt.executeUpdate();
            System.out.println("üíæ Saved {{lowercase machineName}} snapshot: " + snapshot.getMachineId() + " in state " + snapshot.getStateId());
            return rowsAffected > 0;
            
        } catch (SQLException e) {
            System.err.println("‚ùå Failed to save {{lowercase machineName}} snapshot: " + e.getMessage());
            return false;
        }
    }
    
    /**
     * Custom load function for {{lowercase machineName}} snapshots
     */
    public static StateMachineSnapshotEntity load{{machineName}}Snapshot(Connection conn, String machineId) {
        String sql = "SELECT machine_id, state, context_data, timestamp, is_offline " +
                    "FROM {{lowercase machineName}}_snapshots WHERE machine_id = ? ORDER BY timestamp DESC LIMIT 1";
        
        try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
            pstmt.setString(1, machineId);
            
            try (ResultSet rs = pstmt.executeQuery()) {
                if (rs.next()) {
                    StateMachineSnapshotEntity snapshot = new StateMachineSnapshotEntity();
                    snapshot.setMachineId(rs.getString("machine_id"));
                    snapshot.setStateId(rs.getString("state"));
                    snapshot.setContext(rs.getString("context_data"));
                    snapshot.setTimestamp(rs.getTimestamp("timestamp").toLocalDateTime());
                    snapshot.setIsOffline(rs.getBoolean("is_offline"));
                    
                    System.out.println("üìñ Loaded {{lowercase machineName}} snapshot: " + machineId + " in state " + snapshot.getStateId());
                    return snapshot;
                }
            }
        } catch (SQLException e) {
            System.err.println("‚ùå Failed to load {{lowercase machineName}} snapshot: " + e.getMessage());
        }
        
        return null;
    }
    
    /**
     * Custom initialization function for {{lowercase machineName}} table
     */
    public static Boolean init{{machineName}}Table(Connection conn) {
        String createTableSql = "CREATE TABLE IF NOT EXISTS {{lowercase machineName}}_snapshots (" +
                "id BIGINT AUTO_INCREMENT PRIMARY KEY, " +
                "machine_id VARCHAR(255) NOT NULL, " +
                "state VARCHAR(100) NOT NULL, " +
                "context_data TEXT, " +
                "timestamp TIMESTAMP NOT NULL, " +
                "is_offline BOOLEAN DEFAULT FALSE, " +
                "INDEX idx_machine_id (machine_id), " +
                "INDEX idx_timestamp (timestamp)" +
                ")";
        
        try (PreparedStatement pstmt = conn.prepareStatement(createTableSql)) {
            pstmt.execute();
            System.out.println("üóÑÔ∏è {{machineName}} snapshots table initialized");
            return true;
        } catch (SQLException e) {
            System.err.println("‚ùå Failed to initialize {{lowercase machineName}} table: " + e.getMessage());
            return false;
        }
    }
    {{/if}}
}`,

  // State enum template
  stateEnum: `package {{packageBase}};

/**
 * States for {{machineName}}
 * Generated by State Machine Scaffolder
 */
public enum {{stateName}} {
    {{#each states}}
    {{uppercase this}}{{#unless @last}},{{/unless}}
    {{/each}}
}`,

  // Context class template
  contextClass: `package {{packageBase}};

import com.fasterxml.jackson.annotation.JsonProperty;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.AllArgsConstructor;
{{#each imports}}
import {{this}};
{{/each}}

/**
 * Context data for {{machineName}}
 * Generated by State Machine Scaffolder
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class {{contextName}} {
    {{#each fields}}
    @JsonProperty("{{name}}")
    private {{type}} {{name}};
    
    {{/each}}
}`,

  // Event class template
  eventClass: `package {{packageBase}}.events;

import com.telcobright.statemachine.events.StateMachineEvent;

/**
 * {{eventName}} event for {{machineName}}
 * Generated by State Machine Scaffolder
 */
public class {{eventName}} implements StateMachineEvent {
    
    public static final String EVENT_TYPE = "{{uppercase eventName}}";
    
    private final Object payload;
    private final long timestamp;
    
    public {{eventName}}() {
        this(null);
    }
    
    public {{eventName}}(Object payload) {
        this.payload = payload;
        this.timestamp = System.currentTimeMillis();
    }
    
    @Override
    public String getEventType() {
        return EVENT_TYPE;
    }
    
    @Override
    public String getDescription() {
        return "{{eventName}} event" + (payload != null ? " with payload: " + payload : "");
    }
    
    @Override
    public Object getPayload() {
        return payload;
    }
    
    @Override
    public long getTimestamp() {
        return timestamp;
    }
}`,

  // Event registry template
  eventRegistry: `package {{packageBase}}.events;

import java.util.HashMap;
import java.util.Map;

import com.telcobright.statemachine.events.StateMachineEvent;

/**
 * Registry to map {{lowercase machineName}} event classes to their event type strings
 * Generated by State Machine Scaffolder
 */
public class {{machineName}}EventTypeRegistry {
    private static final Map<Class<? extends StateMachineEvent>, String> EVENT_TYPE_MAP = new HashMap<>();
    
    static {
        // Register all {{lowercase machineName}}-related event types
        {{#each events}}
        EVENT_TYPE_MAP.put({{this}}.class, {{this}}.EVENT_TYPE);
        {{/each}}
    }
    
    /**
     * Get event type string for a {{lowercase machineName}} event class
     */
    public static String getEventType(Class<? extends StateMachineEvent> eventClass) {
        String eventType = EVENT_TYPE_MAP.get(eventClass);
        if (eventType != null) {
            return eventType;
        }
        
        // Fallback to class name if not registered
        return eventClass.getSimpleName().toUpperCase();
    }
    
    /**
     * Register a new {{lowercase machineName}} event type
     */
    public static void register(Class<? extends StateMachineEvent> eventClass, String eventType) {
        EVENT_TYPE_MAP.put(eventClass, eventType);
    }
    
    /**
     * Check if an event class is registered in this {{lowercase machineName}} domain
     */
    public static boolean is{{machineName}}Event(Class<? extends StateMachineEvent> eventClass) {
        return EVENT_TYPE_MAP.containsKey(eventClass);
    }
}`,

  // State entry/exit handler template
  stateHandler: `package {{packageBase}}.states.{{lowercase stateName}};

/**
 * {{handlerType}} handler for {{uppercase stateName}} state
 * Generated by State Machine Scaffolder
 */
public class {{handlerType}} {
    public static void handle() {
        System.out.println("{{emoji}} {{message}}");
    }
}`,

  // Stay event handler template
  stayEventHandler: `package {{packageBase}}.states.{{lowercase stateName}};

import com.telcobright.statemachine.events.StateMachineEvent;

/**
 * {{eventName}} event handler for {{uppercase stateName}} state - stays in same state
 * Generated by State Machine Scaffolder
 */
public class On{{eventName}}_{{capitalize stateName}} {
    public static void handle(StateMachineEvent event) {
        System.out.println("{{emoji}} {{eventName}} received in {{uppercase stateName}} state: " + event.getPayload());
        // TODO: Implement {{methodName}} logic
    }
}`,

  // Test runner template
  testRunner: `package {{packageBase}};

import {{packageBase}}.events.*;

/**
 * Test runner for {{machineName}}
 * Generated by State Machine Scaffolder
 */
public class {{machineName}}TestRunner {
    
    public static void main(String[] args) {
        System.out.println("=== {{machineName}} Test Runner ===\\n");
        
        // Create the state machine
        {{machineName}} {{lowercase machineName}} = new {{machineName}}();
        var machine = {{lowercase machineName}}.createMachine("{{lowercase machineName}}-001");
        
        // Test scenario
        System.out.println("\\nüìû Starting test scenario...\\n");
        
        {{#each testScenario}}
        // {{comment}}
        machine.sendEvent(new {{event}}({{#if payload}}"{{payload}}"{{/if}}));
        Thread.sleep({{delay}});
        
        {{/each}}
        
        System.out.println("\\n‚úÖ Test scenario completed!");
    }
}`,

  // Package info template
  packageInfo: `/**
 * {{machineName}} state machine implementation
 * Generated by State Machine Scaffolder
 */
package {{packageBase}};`
};

/**
 * Parse DSL-like structure from scaffolder specification
 */
function parseDSL(spec) {
  const lines = spec.split('\n').map(line => line.trim()).filter(line => line);
  const result = {
    packageBase: '',
    machineName: '',
    persistenceType: null,
    initialState: '',
    states: [],
    events: new Set(),
    contextFields: []
  };

  let currentState = null;

  for (const line of lines) {
    // Package base
    if (line.includes('packageBase(')) {
      result.packageBase = line.match(/packageBase\("(.+?)"\)/)[1];
    }
    // Machine name
    else if (line.includes('.define(')) {
      result.machineName = line.match(/define\("(.+?)"\)/)[1];
    }
    // Persistence type
    else if (line.includes('.persistedIn(')) {
      result.persistenceType = line.match(/persistedIn\("(.+?)"\)/)[1];
    }
    // Initial state
    else if (line.includes('.startWith(')) {
      result.initialState = line.match(/startWith\("(.+?)"\)/)[1];
    }
    // State definition
    else if (line.includes('.state(')) {
      const stateMatch = line.match(/state\("(.+?)"\)/);
      if (stateMatch) {
        currentState = {
          name: stateMatch[1],
          offline: line.includes('.offline()'),
          transitions: [],
          stayEvents: []
        };
        result.states.push(currentState);
      }
    }
    // Event transition
    else if (line.includes('.onEvent(') && currentState) {
      const match = line.match(/onEvent\("(.+?)"\)\.goTo\("(.+?)"\)/);
      if (match) {
        currentState.transitions.push({
          event: match[1],
          toState: match[2]
        });
        result.events.add(match[1]);
      }
    }
    // Stay event
    else if (line.includes('.stayOn(') && currentState) {
      const match = line.match(/stayOn\("(.+?)",\s*"(.+?)"\)/);
      if (match) {
        currentState.stayEvents.push({
          event: match[1],
          methodName: match[2]
        });
        result.events.add(match[1]);
      }
    }
    // Context fields
    else if (line.includes('.contextFields(')) {
      const fieldsMatch = line.match(/contextFields\(([\s\S]+?)\)/);
      if (fieldsMatch) {
        const fields = fieldsMatch[1].split(',').map(f => {
          const field = f.trim().replace(/"/g, '');
          const [name, type] = field.split(':');
          return { name, type };
        });
        result.contextFields = fields;
      }
    }
  }

  return result;
}

/**
 * Generate test scenario based on state transitions
 */
function generateTestScenario(dsl) {
  const scenario = [];
  
  // Find path from initial state through all states
  const visited = new Set();
  const queue = [dsl.initialState];
  
  while (queue.length > 0) {
    const currentStateName = queue.shift();
    if (visited.has(currentStateName)) continue;
    visited.add(currentStateName);
    
    const state = dsl.states.find(s => s.name === currentStateName);
    if (!state) continue;
    
    state.transitions.forEach(t => {
      scenario.push({
        comment: `Trigger ${t.event} to transition from ${currentStateName} to ${t.toState}`,
        event: t.event,
        payload: null,
        delay: 1000
      });
      queue.push(t.toState);
    });
  }
  
  return scenario;
}

/**
 * Determine imports needed for context fields
 */
function getContextImports(fields) {
  const imports = new Set();
  fields.forEach(field => {
    if (field.type === 'LocalDateTime') {
      imports.add('java.time.LocalDateTime');
    } else if (field.type === 'Date') {
      imports.add('java.util.Date');
    } else if (field.type === 'List') {
      imports.add('java.util.List');
    } else if (field.type === 'Map') {
      imports.add('java.util.Map');
    }
  });
  return Array.from(imports);
}

/**
 * Generate all files for the state machine
 */
async function generateFiles(dsl, outputDir) {
  const baseDir = path.join(outputDir, ...dsl.packageBase.split('.'));
  
  // Prepare template data
  const templateData = {
    ...dsl,
    stateName: `${dsl.machineName}State`,
    contextName: `${dsl.machineName.replace('Machine', '')}Context`,
    events: Array.from(dsl.events),
    states: dsl.states.map(s => s.name),
    imports: getContextImports(dsl.contextFields),
    testScenario: generateTestScenario(dsl)
  };

  // Create directories
  await fs.mkdir(path.join(baseDir, 'events'), { recursive: true });
  for (const state of dsl.states) {
    await fs.mkdir(path.join(baseDir, 'states', state.name.toLowerCase()), { recursive: true });
  }

  // Generate main state machine class
  await generateFile(
    path.join(baseDir, `${dsl.machineName}.java`),
    templates.stateMachine,
    { ...templateData, states: dsl.states }
  );

  // Generate state enum
  await generateFile(
    path.join(baseDir, `${templateData.stateName}.java`),
    templates.stateEnum,
    templateData
  );

  // Generate context class
  await generateFile(
    path.join(baseDir, `${templateData.contextName}.java`),
    templates.contextClass,
    { ...templateData, fields: dsl.contextFields }
  );

  // Generate event classes
  for (const event of dsl.events) {
    await generateFile(
      path.join(baseDir, 'events', `${event}.java`),
      templates.eventClass,
      { ...templateData, eventName: event }
    );
  }

  // Generate event registry
  await generateFile(
    path.join(baseDir, 'events', `${dsl.machineName}EventTypeRegistry.java`),
    templates.eventRegistry,
    templateData
  );

  // Generate state handlers
  for (const state of dsl.states) {
    // OnEntry handler
    await generateFile(
      path.join(baseDir, 'states', state.name.toLowerCase(), 'OnEntry.java'),
      templates.stateHandler,
      {
        ...templateData,
        stateName: state.name,
        handlerType: 'OnEntry',
        emoji: '‚û°Ô∏è',
        message: `Entering ${state.name.toUpperCase()} state`
      }
    );

    // OnExit handler
    await generateFile(
      path.join(baseDir, 'states', state.name.toLowerCase(), 'OnExit.java'),
      templates.stateHandler,
      {
        ...templateData,
        stateName: state.name,
        handlerType: 'OnExit',
        emoji: '‚¨ÖÔ∏è',
        message: `Exiting ${state.name.toUpperCase()} state`
      }
    );

    // Stay event handlers
    for (const stayEvent of state.stayEvents) {
      await generateFile(
        path.join(baseDir, 'states', state.name.toLowerCase(), `On${stayEvent.event}_${state.name}.java`),
        templates.stayEventHandler,
        {
          ...templateData,
          stateName: state.name,
          eventName: stayEvent.event,
          methodName: stayEvent.methodName,
          emoji: 'üîÑ'
        }
      );
    }
  }

  // Generate test runner
  await generateFile(
    path.join(baseDir, `${dsl.machineName}TestRunner.java`),
    templates.testRunner,
    templateData
  );

  // Generate package-info.java
  await generateFile(
    path.join(baseDir, 'package-info.java'),
    templates.packageInfo,
    templateData
  );

  console.log(`‚úÖ Generated ${dsl.machineName} state machine in ${baseDir}`);
}

/**
 * Generate a single file from template
 */
async function generateFile(filePath, template, data) {
  const compiled = handlebars.compile(template);
  const content = compiled(data);
  await fs.writeFile(filePath, content);
  console.log(`  üìÑ ${path.basename(filePath)}`);
}

/**
 * CLI setup
 */
program
  .name('statemachine-scaffolder')
  .description('Generate Java state machine code from DSL specification')
  .version('1.0.0');

program
  .command('generate')
  .description('Generate state machine from a specification file')
  .requiredOption('-s, --spec <file>', 'Path to the scaffolder specification file')
  .requiredOption('-o, --output <dir>', 'Output directory for generated code')
  .action(async (options) => {
    try {
      console.log('üöÄ State Machine Scaffolder\n');
      
      // Read specification file
      const specContent = await fs.readFile(options.spec, 'utf-8');
      
      // Parse DSL
      const dsl = parseDSL(specContent);
      console.log(`üìñ Parsed specification for ${dsl.machineName}`);
      console.log(`   States: ${dsl.states.map(s => s.name).join(', ')}`);
      console.log(`   Events: ${Array.from(dsl.events).join(', ')}\n`);
      
      // Generate files
      await generateFiles(dsl, options.output);
      
      console.log('\n‚ú® Scaffolding complete!');
    } catch (error) {
      console.error('‚ùå Error:', error.message);
      process.exit(1);
    }
  });

program
  .command('init')
  .description('Initialize a new state machine specification')
  .requiredOption('-n, --name <name>', 'State machine name (e.g., OrderMachine)')
  .requiredOption('-p, --package <package>', 'Base package (e.g., com.company.orders)')
  .option('-o, --output <file>', 'Output specification file', './Scaffolder.java')
  .action(async (options) => {
    const template = `package ${options.package};

import com.telcobright.statemachine.dsl.StateMachineDsl;

/**
 * Scaffolding specification for the ${options.name} state machine.
 * Generated by State Machine Scaffolder
 */
public class ${options.name}Scaffolder {

    public static void define() {
        StateMachineDsl.packageBase("${options.package}")
            .define("${options.name}")
            .persistedIn("mysql")
            .startWith("INITIAL")

            .state("INITIAL")
                .onEvent("Start").goTo("PROCESSING")
                .endState()

            .state("PROCESSING")
                .onEvent("Complete").goTo("COMPLETED")
                .onEvent("Fail").goTo("FAILED")
                .endState()

            .state("COMPLETED")
                .endState()

            .state("FAILED")
                .endState()

            .contextFields(
                "id:String",
                "createdAt:LocalDateTime"
            )

            .build();
    }
}`;

    await fs.writeFile(options.output, template);
    console.log(`‚úÖ Created specification template: ${options.output}`);
    console.log(`\nüìù Edit the specification and then run:`);
    console.log(`   node scaffolder.js generate -s ${options.output} -o ./src/main/java`);
  });

program.parse(process.argv);

// Export for testing
module.exports = { parseDSL, generateFiles, templates };