package com.telcobright.statemachineexamples.smsmachine;

import com.telcobright.statemachine.GenericStateMachine;
import com.telcobright.statemachine.StateMachineRegistry;
import com.telcobright.statemachineexamples.smsmachine.events.SendAttempt;
import com.telcobright.statemachineexamples.smsmachine.events.DeliveryReport;
import com.telcobright.statemachineexamples.smsmachine.events.SendFailed;
import com.telcobright.statemachineexamples.smsmachine.events.StatusUpdate;
import com.telcobright.statemachineexamples.smsmachine.events.Retry;
import com.telcobright.statemachineexamples.smsmachine.states.sending.OnStatusUpdate_SENDING;
import com.telcobright.statemachine.persistence.StateMachineSnapshotEntity;
import com.telcobright.statemachine.persistence.StateMachineSnapshotRepository;
import com.telcobright.statemachine.timeout.TimeoutManager;
import com.telcobright.statemachine.state.EnhancedStateConfig;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.Properties;
import java.io.InputStream;
import java.io.IOException;
import java.util.function.BiFunction;
import java.util.function.Function;

/**
 * SmsMachine state machine implementation
 * Generated by State Machine Scaffolder
 */
public class SmsMachine extends GenericStateMachine {
    
    public SmsMachine(String id, StateMachineSnapshotRepository snapshotRepository, 
                     TimeoutManager timeoutManager, StateMachineRegistry registry) {
        super(id, snapshotRepository, timeoutManager, registry);
        
        System.out.println("üîß Created SmsMachine: " + id);
    }
    
    /**
     * Create and configure the SMS state machine using fluent builder
     */
    public static SmsMachine create(String machineId) {
        return SmsMachineBuilder.create(machineId)
            .initialState(SmsMachineState.QUEUED)
            .state(SmsMachineState.QUEUED)
                .on(SendAttempt.class).to(SmsMachineState.SENDING)
                .then()
            .state(SmsMachineState.SENDING)
                .on(DeliveryReport.class).to(SmsMachineState.DELIVERED)
                .on(SendFailed.class).to(SmsMachineState.FAILED)
                .stay(StatusUpdate.class, OnStatusUpdate_SENDING::handle)
                .then()
            .state(SmsMachineState.DELIVERED)
                .then()
            .state(SmsMachineState.FAILED)
                .on(Retry.class).to(SmsMachineState.QUEUED)
                .then()
            .build();
    }
    
    
    /**
     * Load active profile from profile.properties
     */
    private static String loadActiveProfile() {
        Properties props = new Properties();
        try (InputStream input = SmsMachine.class.getClassLoader().getResourceAsStream("profile.properties")) {
            if (input != null) {
                props.load(input);
                String profile = props.getProperty("active.profile", "dev");
                System.out.println("üîß Active profile: " + profile);
                return profile;
            }
        } catch (IOException e) {
            System.err.println("‚ö†Ô∏è Could not load profile.properties, using default: dev");
        }
        return "dev"; // default profile
    }
    
    // ======================== CUSTOM SQL PERSISTENCE METHODS ========================
    
    /**
     * Custom save function for smsmachine snapshots
     */
    public static Boolean saveSmsMachineSnapshot(Connection conn, StateMachineSnapshotEntity snapshot) {
        String sql = "INSERT INTO smsmachine_snapshots (machine_id, state, context_data, timestamp, is_offline) VALUES (?, ?, ?, ?, ?)";
        
        try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
            pstmt.setString(1, snapshot.getMachineId());
            pstmt.setString(2, snapshot.getStateId());
            pstmt.setString(3, snapshot.getContext());
            pstmt.setTimestamp(4, Timestamp.valueOf(snapshot.getTimestamp()));
            pstmt.setBoolean(5, snapshot.getIsOffline());
            
            int rowsAffected = pstmt.executeUpdate();
            System.out.println("üíæ Saved smsmachine snapshot: " + snapshot.getMachineId() + " in state " + snapshot.getStateId());
            return rowsAffected > 0;
            
        } catch (SQLException e) {
            System.err.println("‚ùå Failed to save smsmachine snapshot: " + e.getMessage());
            return false;
        }
    }
    
    /**
     * Custom load function for smsmachine snapshots
     */
    public static StateMachineSnapshotEntity loadSmsMachineSnapshot(Connection conn, String machineId) {
        String sql = "SELECT machine_id, state, context_data, timestamp, is_offline " +
                    "FROM smsmachine_snapshots WHERE machine_id = ? ORDER BY timestamp DESC LIMIT 1";
        
        try (PreparedStatement pstmt = conn.prepareStatement(sql)) {
            pstmt.setString(1, machineId);
            
            try (ResultSet rs = pstmt.executeQuery()) {
                if (rs.next()) {
                    StateMachineSnapshotEntity snapshot = new StateMachineSnapshotEntity();
                    snapshot.setMachineId(rs.getString("machine_id"));
                    snapshot.setStateId(rs.getString("state"));
                    snapshot.setContext(rs.getString("context_data"));
                    snapshot.setTimestamp(rs.getTimestamp("timestamp").toLocalDateTime());
                    snapshot.setIsOffline(rs.getBoolean("is_offline"));
                    
                    System.out.println("üìñ Loaded smsmachine snapshot: " + machineId + " in state " + snapshot.getStateId());
                    return snapshot;
                }
            }
        } catch (SQLException e) {
            System.err.println("‚ùå Failed to load smsmachine snapshot: " + e.getMessage());
        }
        
        return null;
    }
    
    /**
     * Custom initialization function for smsmachine table
     */
    public static Boolean initSmsMachineTable(Connection conn) {
        String createTableSql = "CREATE TABLE IF NOT EXISTS smsmachine_snapshots (" +
                "id BIGINT AUTO_INCREMENT PRIMARY KEY, " +
                "machine_id VARCHAR(255) NOT NULL, " +
                "state VARCHAR(100) NOT NULL, " +
                "context_data TEXT, " +
                "timestamp TIMESTAMP NOT NULL, " +
                "is_offline BOOLEAN DEFAULT FALSE, " +
                "INDEX idx_machine_id (machine_id), " +
                "INDEX idx_timestamp (timestamp)" +
                ")";
        
        try (PreparedStatement pstmt = conn.prepareStatement(createTableSql)) {
            pstmt.execute();
            System.out.println("üóÑÔ∏è SmsMachine snapshots table initialized");
            return true;
        } catch (SQLException e) {
            System.err.println("‚ùå Failed to initialize smsmachine table: " + e.getMessage());
            return false;
        }
    }
    
    // ===================== ABSTRACT METHOD IMPLEMENTATIONS =====================
    
    @Override
    public Boolean save(Connection conn, StateMachineSnapshotEntity snapshot) {
        return saveSmsMachineSnapshot(conn, snapshot);
    }
    
    @Override
    public StateMachineSnapshotEntity load(Connection conn, String machineId) {
        return loadSmsMachineSnapshot(conn, machineId);
    }
    
    @Override
    public Boolean init(Connection conn) {
        return initSmsMachineTable(conn);
    }
}